#!/bin/env python
# -*- coding: utf-8 -*-
import os
import sys
import time
import codecs
import re
import urllib3
from urllib3 import util
sys.path.append('../../')
from util import Utilty

# Type of printing.
OK = 'ok'         # [*]
NOTE = 'note'     # [+]
FAIL = 'fail'     # [-]
WARNING = 'warn'  # [!]
NONE = 'none'     # No label.


# Classifier class.
class ClassifierSignature:
    def __init__(self):
        self.full_path = os.path.dirname(os.path.abspath(__file__))
        self.signature_path = os.path.join(self.full_path, 'signature')
        self.util = Utilty()

    # Identify product name.
    def identify_product(self, categoy, response):
        prod_info_list = []
        file_name = 'signature_' + categoy + '.txt'
        try:
            # Judge product using pattern matching.
            with codecs.open(os.path.join(self.signature_path, file_name), 'r', 'utf-8') as fin:
                matching_patterns = fin.readlines()
                for pattern in matching_patterns:
                    items = pattern.replace('\r', '').replace('\n', '').split('@')
                    product = items[0].lower()
                    signature = items[2]
                    list_match = re.findall(signature, response, flags=re.IGNORECASE)
                    if len(list_match) != 0:
                        # Check version.
                        version_info = ''
                        for target_string in list_match:
                            version_info = self.extract_version(target_string).lower()
                            if version_info != '':
                                break

                        # Add product name and version.
                        if str(items[1]) != '':
                            prod_info_list.append(product + '@' + str(items[1]))
                        elif version_info != '':
                            prod_info_list.append(product + '@' + version_info)
                        else:
                            prod_info_list.append(product + '@-')
        except Exception as err:
            self.util.print_message(WARNING, '{}'.format(err))
        return prod_info_list

    # Extract version.
    def extract_version(self, target_string):
        # Regression list for cutting version.
        regex_list = [r'(\d{1,3}\.\d{1,3}\.\d{1,3}).*',
                      r'(\d{1,3}\.\d{1,3}).*',
                      r'(\d{1,3}).*',
                      r'(\d{1,3}\.\d{1,3}[a-z]\d{1,3}).*',
                      r'(\d{1,3}\.\d{1,3}\.\d[a-z]{1,3}).*',
                      r'(\d\.[xX|\*]).*']

        version_info = ''
        for regex_pattern in regex_list:
            version_list = re.findall(regex_pattern, target_string)
            if len(version_list) != 0:
                version_info = str(version_list[0])
                break
        return version_info

    # Classifier product name using signatures.
    def classifier_signature(self, target_info, client):
        product_list = []
        for target in target_info:
            for target_url in target[2]:
                # Check target url.
                parsed = None
                try:
                    parsed = util.parse_url(target_url)
                except Exception as err:
                    self.util.print_exception(err, 'Parsed error: {}'.format(target_url))
                    continue

                # Get HTTP response (header + body).
                response = ''
                http = urllib3.PoolManager(timeout=self.util.http_timeout)
                try:
                    client.keep_alive()
                    self.util.print_message(OK, '{}  {}'.format(self.util.get_current_date('%Y-%m-%d %H:%M:%S'),
                                                               target_url))
                    res = http.request('GET', target_url)
                    for header in res.headers.items():
                        response += header[0] + ': ' + header[1] + '\r\n'
                    response += '\r\n\r\n' + res.data.decode('utf-8')
                except Exception as err:
                    self.util.print_exception(err, 'Target URL: {}'.format(target_url))
                    continue

                for category in ['os', 'web', 'framework', 'cms']:
                    prod_info = self.identify_product(category, self.util.delete_ctrl_char(response))
                    for product in prod_info:
                        port_num = 80
                        path_item = os.path.split(parsed.path)
                        if parsed.port is not None:
                            port_num = parsed.port
                        if path_item[0].endswith('/') is False:
                            product_list.append(product + '@' + str(port_num) + '@' + path_item[0] + '/')
                        else:
                            product_list.append(product + '@' + str(port_num) + '@' + path_item[0])
                time.sleep(1.0)

        # Delete duplication.
        uniq_product = []
        tmp_list = []
        for item in list(set(product_list)):
            tmp_item = item.split('@')
            tmp = tmp_item[0] + tmp_item[2]
            if tmp not in tmp_list:
                tmp_list.append(tmp)
                uniq_product.append(item)
        return uniq_product
