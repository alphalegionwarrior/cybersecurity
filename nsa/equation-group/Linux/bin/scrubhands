#!/bin/bash -m
#TODO: put "containing..." above is htis ok prompt
#version:
# We want -v output to be just two digits, so scrubver is #.#
# and suitever can have whole #.#.#.# in it.

#TODO: pitchline not populating right? line 1932

SCRUBVER=6.007000010
SUITEVER=6.7.0.10
SCRUBCMDLINE="$0 $*"
SUITELOC=""
GEN3="`cat /mnt/hgfs/host/host.txt 2>/dev/null`"
export SUITELOC GEN3
TOP=/home/black/tmp
DATE="`date -u +'%Y%m%d-%H%M'`"


PROG=`basename ${0}`
NEWPROG=""
echo $PROG | grep -q "\.new" && NEWPROG=$PROG
CALLEDAS="${0} ${*}"
JSCANNERFILE="jscanner.zip"

[ -f /usr/local/bin/bashfunctions ] && source /usr/local/bin/bashfunctions

histclean() {
  HISTCLEAN=""
  TMPHIST=/tmp/.h.$$
  DOFILES="$* `ls /.*history /*/.*history /*/*/.*history 2>/dev/null`"

  for F in $DOFILES ; do
    [ -f "$F" ] || continue
    egrep -q "shutdown|reboot|halt|init 0" $F || continue
    egrep -v "shutdown|reboot|halt|init 0" $F > $TMPHIST
    touch -r $F $TMPHIST
    cat $TMPHIST > $F
    touch -r $TMPHIST $F
    HISTCLEAN="$HISTCLEAN $F"
  done
  [ "$HISTCLEAN" ] && notered "Cleaned #shutdown|reboot|halt|init 0# lines from $HISTCLEAN"
  rm -f $TMPHIST
  unset TMPHIST HISTCLEAN DOFILES
}


fixpath() {
    # Take any number of PATHs or PATH variables as input,
    # Return/echo one in that order with no duplicates (via echo, so use
    # backticks or other redirection to take the return value and use it).
    # Spaces in any individual PATH entry will be lost, do not do that.
    # However, along the way, we:
        # Remove all trailing slashes
        # Make all slashes single
        # Skip . and ./ and any that start with ../

    export NEWPATH=
    unset DONEFIRST
    echo -n PATH=
 #    echo $* | sed "s,//*,/,g" | \   # Make all slashes single
 #    sed "s/PATH=//g" | \            # Get rid of PATH= if there
 #    tr ":" " " | \                  # Change all : to a space
 #    tr " " "\n" | \                 # Put one path per line 
 #    while read P                    # Define P once per path
    echo $* | sed "s,//*,/,g" | sed "s/PATH=//g" | tr ":" " " | tr " " "\n" | while read P ; do
        # Remove all trailing slashes
        P=`echo $P | sed "s,/*$,,g"`
        echo :$NEWPATH: | grep -q ":$P:" && continue
        # Skip . and ./ and any that start with ../
        [ "$P" = "." -o "$P" = "./" ] && continue
        [ "$P" = ".." -o "${P:0:3}" = "../" ] && continue
        NEWPATH=$NEWPATH:$P
        [ "$DONEFIRST" ] && echo -n :
        echo -n $P
        DONEFIRST=done
    done
    echo
}
ColorsOff() {
    unset COLOR_SUCCESS
    unset COLOR_FAILURE
    unset COLOR_WARNING
    unset COLOR_NORMAL
    unset COLOR_NOTE
    unset SETCOLOR_SUCCESS
    unset SETCOLOR_FAILURE
    unset SETCOLOR_WARNING
    unset SETCOLOR_NORMAL
    unset SETCOLOR_NOTE
}
PreserveFile() {
  # Save off $1 if it exists as $1.duplicate.TIMESTAMP.
  # If $2 given, save at most that many dupes.
  [ "$1" ] || return
  [ -e $1 ] || return
  MYDATE=`date -u +%Y%m%d%H%M%S`
  # Make sure we only have digits in KEEP
  MYKEEP=`echo $2 | sed "s/[^0-9]//g"`
  if [ "$MYKEEP" ] ; then
    MYCOUNT=1
    ls -1t $1.DUPLICATE* |
    while read name ; do
        [ $((MYCOUNT++)) -ge $MYKEEP ] || continue
        rm -f $name
    done
  fi
  mv $1 $1.DUPLICATE.$MYDATE
  unset MYDATE MYKEEP MYCOUNT
}

note() {
    unset N
    if [ "$1" = "-n" ] ; then
      N=$1
      shift
    fi
    echo -e $N "$COLOR_NOTE${*}$COLOR_NORMAL"
}
notered() {
    unset N EXIT
    [ "$1" = "exit" ] && EXIT=1 && shift
    if [ "$1" = "-n" ] ; then
      N=$1
      shift
    fi
    echo -e $N "$COLOR_FAILURE${*}$COLOR_NORMAL"
    [ "$EXIT" ] && exit
}


usage() {
    unset EXIT
    [ "$1" = "exit" ] && EXIT=1 && shift
    if [ "$1" = "-h" -a "$usagetext" ] ; then
        shift
        echo -e "$usagetext"
    fi
    # We want -v output to be just two digits, so scrubver is #.#
    # and suitever can have whole #.#.#.# in it.
    if [ "$1" = "-v" -o "$1" = "-h" ] ; then
        if [ ! "$VER" -a "$SCRUBVER" ] ; then
            echo "$PROG version $SCRUBVER"
        elif [ "$VER" ] ; then
            echo "$PROG version $VER"
        else
            echo "$PROG -- unknown version number"
        fi
        shift
    fi
    ERRSTR="${*}"
    if [ "$ERRSTR" ] ; then
        notered "\a${ERRSTR}"
    fi
    [ "$EXIT" ] && exit
} # end usage


COLOR_SUCCESS="\\033[1;32m"
COLOR_FAILURE="\\033[1;31m"
COLOR_WARNING="\\033[1;33m"
COLOR_NORMAL="\\033[0;39m"
COLOR_NOTE="\\033[0;34m"
SETCOLOR_SUCCESS="echo -en $COLOR_SUCCESS"
SETCOLOR_FAILURE="echo -en $COLOR_FAILURE"
SETCOLOR_WARNING="echo -en $COLOR_WARNING"
SETCOLOR_NORMAL="echo -en $COLOR_NORMAL"
SETCOLOR_NOTE="echo -en $COLOR_NOTE"

tmpfixdeletelater() {
#    echo $PROG is wiping all instances of es.py in the background with:
#    echo "updatedb && rm -f \`locate es.py | grep \"\\/es.py\$\"\` &"
#    updatedb && rm -f `locate es.py | grep "\/es.py$"` &
    [ "$TESTGETOPDATA" ] && return
    sleep 2
    
    cp -pf /etc/hosts /etc/hosts.BADMAYBE.$EXT
    cp -pf /etc/ppp/ip-up.local /etc/ppp/ip-up.local.BADMAYBE.$EXT
    if [ ! -e /etc/hosts.DONOTCHANGE ] ; then
      echo $PROG is fixing /etc/hosts and /etc/ppp/ip-up.local if they need it
      sleep 1
      EXT=`date +%Y%m%d%H%M`
      [ -e /etc/hosts.BADMAYBE.$EXT ] && touch /etc/hosts.BADMAYBE.$EXT
      cat <<EOF > /etc/hosts
# Do not remove the following line, or various programs
# that require network functionality will fail.
127.0.0.1       localhost.localdomain   localhost
EOF
      IP=`ifconfig ${PUBLICETHER} | grep inet | awk '{print $2}' | cut -f 2 -d ":"` 
      HOST="$GEN3HOST"
      [ "$HOST" ] || HOST=`hostname | tr "A-Z" "a-z"`
      [ "$HOST" ] || HOST=noname
      [ "$IP" ] || IP=127.0.0.1
      echo -e "$IP    $HOST" >> /etc/hosts
    else
      echo Leaving /etc/hosts alone since /etc/hosts.DONOTCHANGE exists
    fi
    if [ ! -e /etc/ppp/ip-up.local.DONOTCHANGE ] ; then
      echo $PROG is fixing /etc/hosts and /etc/ppp/ip-up.local if they need it

      [ -e /etc/ppp/ip-up.local.BADMAYBE.$EXT ] || touch /etc/ppp/ip-up.local.BADMAYBE.$EXT
      cat <<EOF > /etc/ppp/ip-up.local
/sbin/route del default
/sbin/route add default ppp0
rm -f /etc/resolv.conf.last
mv /etc/resolv.conf /etc/resolv.conf.last
if [ "\$DNS1" ] ; then
        echo nameserver \$DNS1 >> /etc/resolv.conf
fi
if [ "\$DNS2" ] ; then
        echo nameserver \$DNS2 >> /etc/resolv.conf
fi
if [ -e /etc/ppp/resolv.conf ] ; then
        cat /etc/ppp/resolv.conf >> /etc/resolv.conf
fi
chmod ugo+r /etc/resolv.conf
/bin/touch /var/lock/subsys/ppp_started
EOF
      chmod 755 /etc/ppp/ip-up.local
      chmod 644 /etc/hosts /etc/resolv.conf
    else
      echo Leaving /etc/ppp/ip-up.local alone since /etc/ppp/ip-up.local.DONOTCHANGE exists
    fi    
    echo FILES NOW CONTAIN:
    more /etc/ppp/ip-up.local /etc/hosts | cat
    
    echo
    echo Here are differences from the old copies:
    
    echo diff /etc/ppp/ip-up.local /etc/ppp/ip-up.local.BADMAYBE.$EXT
    diff /etc/ppp/ip-up.local /etc/ppp/ip-up.local.BADMAYBE.$EXT && rm -f /etc/ppp/ip-up.local.BADMAYBE.$EXT && echo NO DIFFERENCE
    echo
    echo diff /etc/hosts /etc/hosts.BADMAYBE.$EXT
    diff /etc/hosts /etc/hosts.BADMAYBE.$EXT && rm -f /etc/hosts.BADMAYBE.$EXT && echo NO DIFFERENCE
    
    unset EXT
    sleep 1
}

runsuite() {

  # Run Suite-Select-Linux if there and $PRIVATEETHER is not yet up
  [ "$SUITEFILE" ] || SUITEFILE=`/bin/ls -1rt /root/LINUXVNC/Suite-Select-Linux* 2>/dev/null | tail -1`
  [ "$SUITEFILE" ] || SUITEFILE=`/bin/ls -1rt /root/Desktop/Suite-Select-Linux* 2>/dev/null | tail -1`
  if [ "$SUITEFILE" -a -x "$SUITEFILE" ] ; then
    # If we have $SUITEFILE here, replace Desktop one with it
    #    # We are not responsible for updating Suite-Select-Linux
    #    if [ -s $TOP/$DATE/bin/Suite-Select-Linux ] ; then
    #	diff -q $TOP/$DATE/bin/Suite-Select-Linux /root/Desktop/ >/dev/null 2>/dev/null || \
    #	{
    #	    /bin/cp -p $TOP/$DATE/bin/Suite-Select-Linux /root/Desktop/Suite-Select-Linux
    #	    chmod 755  /root/Desktop/Suite-Select-Linux
    #	    SUITEFILE=/root/Desktop/Suite-Select-Linux
    #	}
    #    fi
    # "clear" command inside here messes up scrubhands output
    cp -p $SUITEFILE $SUITEFILE.scrub
    egrep -q "^[	 ]*clear[	 ]*$" $SUITEFILE && \
    {
	grep -v "^[	 ]*clear[	 ]*$" $SUITEFILE > /tmp/sf
	cat /tmp/sf > $SUITEFILE.scrub
	rm -f /tmp/sf
    }
    touch -r  $SUITEFILE $SUITEFILE.scrub
    egrep -q "tee -a /tmp/suiteinfo" $SUITEFILE || \
    {
	[ -e $SUITEFILE.orig ] || cp -p $SUITEFILE $SUITEFILE.orig
	cat $SUITEFILE | sed "s,\(echo[^>]*IP is:.*\),\1 | tee -a /tmp/suiteinfo," > /tmp/sf
	cat /tmp/sf > $SUITEFILE.scrub
        rm -f /tmp/sf
    }
    touch -r  $SUITEFILE $SUITEFILE.scrub
    # If $PRIVATEETHER is not already up (and also not the default 192.168.254.*),
    # we run Suite-Select-Linux for them
    ADDRNOTSET=`ifconfig $PRIVATEETHER | grep inet.addr:.*192.168.254`
    ETHPRIVSET=`ifconfig | grep $PRIVATEETHER`
    RUNIT=""
    [ ! "$ETHPRIVSET" ] && RUNIT=yes
    [ "$ADDRNOTSET" ] && RUNIT=yes
    # Must always run this except in GEN3 mode
    RUNIT="yes"
    [ "$GEN3" ] && RUNIT=""
    if [ "$RUNIT" ] ; then
        1x -hold -bg white -geometry 80x24+1294+21 -e "$SUITEFILE.scrub"
        note -n "Please select your Suite in the popup window NOW..."
	{
	    C=0
	    while [ 1 ] ; do 
		sleep 1
		C=$((C+1))
		ps -efw | grep -v grep | grep -q "bash .*Suite-Select-Linux" || break
		[ -s /tmp/suiteinfo ] && break
		if [ `echo $C%45 | bc` -eq 0 ] ; then
		    notered "\nYou MUST finish the Suite-Select window NOW\n"
		fi
	    done
	    sleep 2
	    echo
	    [ -s /tmp/suiteinfo ] && grep -2 IP.is: /tmp/suiteinfo
	    echo
	} 
        echo
    else
	SUITETITLE="Suiteinfo-Gen3"
    fi

    SUITENUM=`cat /suite.txt 2>/dev/null`
    [ "$SUITETITLE" ] || SUITETITLE="Suiteinfo-$SUITENUM"
    echo === >> /tmp/suiteinfo
    ( ifconfig $PUBLICETHER ; echo =; ifconfig $PRIVATEETHER ;echo =) | egrep "^[^ ]|inet.addr" | tr -d "\n" | tr '=' '\n' | sed "s/  */ /g" | sed "s/inet addr/IP/g" | sed "s/eth1/\neth1/g" | sed "s/Link encap:Ethernet HWaddr/MAC:/g" | sed "s/Mask/M/g" | sed "s/Bcast/Bc/g" >> /tmp/suiteinfo
    [ "$SUITENUM" ] || SUITENUM=Gen3
    grep -v Analyst /tmp/suiteinfo | sed "s/\(Linux.*\)/\1                                           Suite $SUITENUM/g" > /tmp/suiteinfo2
    1x -geometry 85x6+1284+0 -title $SUITETITLE -bg white -hold -e cat /tmp/suiteinfo2
    (sleep 2 && rm -f /tmp/suiteinfo2 )&
    unset SUITETITLE
  fi

  export PUBLICIP=`ifconfig $PUBLICETHER 2>/dev/null | grep "inet addr" | tail -1 | awk '{print $2}' | sed 's/addr://g'`
  export PRIVATEIP=`ifconfig $PRIVATEETHER 2>/dev/null | grep "inet addr" | tail -1 | awk '{print $2}' | sed 's/addr://g'`

  sleep 1

}

# primary
[ "$TERM" ] || TERM=xterm
[ -x /usr/local/bin/mkzipdev ] && /usr/local/bin/mkzipdev

if [ "$JUSTLOGGEDIN" ] ; then
  echo -en "\a

About to run $PROG, which will delete some files in
$TOP/*.

Abort now if you don't want to run $PROG..."
  TMPCOUNT=5
  while [ $TMPCOUNT -ge 0 ] ; do
    echo -en "$TMPCOUNT...\a"
    TMPCOUNT=`expr $TMPCOUNT - 1`
    usleep 900000
  done
  echo "

Running $PROG
"
fi


usagetext="
$PROG version $SCRUBVER (See bottom for Usage syntax)

${PROG} finds and unpacks the most recent op tarball (or several
if -# is used) on either a USB mountable flash drive, mountable ZIP,
or tar floppy or ZIP disk. ($PROG also refers to the USB drive as
\"ZIP\".) A new dated directory is created in $TOP, with
/current as a link to this directory. Once the op is unpacked, a
scripted window pops up showing the automatic upgrade of some of the
tools in /usr/local/sbin from this op's ./bin directory.

Unless using the -u option, the operator is given an ops environment:
either several scripted windows if the op contains a scripme.override
file in ./etc; or pastables to make them.

${PROG} writes and runs ./bin/getopdata, a perl script specific to
this op. getopdata is what packs up the op after it is over, first
ensuring that no more scripted windows or tcpdumps are running.

Several other scripts are written out each op by ${PROG},
including (those in /current/bin are specific to current op only):
    /current/bin/ethwarn.pl
    /usr/local/bin/ethwarn
    /current/bin/doupgrade
    /current/bin/getopdata
    /current/bin/getmorerats
    /usr/local/bin/4x      (also links to that, 1x, 2x, 3x
				and [1-4]xs and [1-4]xw)

The getmorerats script is called during scrubhands' initial run.
If you copy over ALPHA or BETA NOPEN, which includes a new rats
tarball morerats.tar.bz2 in ./up/, you can run getmorerats again
to set aside the old morerats directories in /current/ and unpack
the new ones.

OPTIONS

 -c        Disable normal autocheckin prompts at end of getopdata
 -f file   use tarball \"file\" instead of floppy or Zip
 -g        Set GEN3 on--automatic if $PRIVATEETHER is in 192.168.254.0/24
 -h/v      Show usage/version
 -I UID    Op User ID (getopdata uses this)
 -m        leave ZIP disk mounted (if found)
 -M MTU    Set the public interface MTU to this value (must be >= 500)
 -n list   Use the comma delimited list of IPs as name servers,
           replacing old resolv.conf.
 -N        means current networking is sufficient, perhaps
           because we're natted somehow.
 -P proj   Project Name (getopdata uses this)
 -s        ignore ./etc/scripme.override, if any
 -S ####   Schedule ID (YYMMDD########), 14 digits.  Or use -S Fake to put
           in a temporary ID and getopdata will require the real one later.
 -t        Use the FG ops disk (no thumb)
 -T ##-##  Your Room-Station numbers
 -U        SKIP the upgrade process (should be done with RC tarballs)
 -u        unpack newest op from ZIP/floppy and use it to upgrade the
           OP system's /usr/local/sbin files, then exit.
 -X        Alternative rat than NOPEN.  Add a line in opnotes denoting this.
           Alternative rat will be set to NONE for post-processing reasons.
 -#        if -# is between -1 and -9, then that many tarballs are
           unpacked from the zip disk. The most recent one is put in
           /current/ and subsequent ones in date order are put in
           /current/op#, for # in 2..9.  I.e., you will have both
           /current/bin and /current/op#/bin. (default is 1 op)

Usage: $PROG [options] <local_ip> <netmask> <router>
   or: $PROG [options] <local_ip>
   or: $PROG [options] <local_ip>/gw-final-octet  (mask defaults to /27)
   or: $PROG [options] <local_ip>/mask/gw       
   or: $PROG [options] 
   or: $PROG [-v]          (shows version)
   or: $PROG [-u]          (only do upgrade of /usr/local/sbin)
   or: $PROG [-h]          (gives this usage statement)

where: if only <local_ip> is given, <netmask> defaults to
       255.255.255.0 and <router> defaults to <local_net.1>

$PROG version $SCRUBVER
suite version $SUITEVER
"
COLOR_SUCCESS="\\033[1;32m"
COLOR_FAILURE="\\033[1;31m"
COLOR_WARNING="\\033[1;33m"
COLOR_NORMAL="\\033[0;39m"
COLOR_NOTE="\\033[0;34m"
SETCOLOR_SUCCESS="echo -en $COLOR_SUCCESS"
SETCOLOR_FAILURE="echo -en $COLOR_FAILURE"
SETCOLOR_WARNING="echo -en $COLOR_WARNING"
SETCOLOR_NORMAL="echo -en $COLOR_NORMAL"
SETCOLOR_NOTE="echo -en $COLOR_NOTE"

# 20060720
# OK, this is weird. Cloned boxes seize up the window the first time
# it sees this color green after any boot. Really? Not kidding.
# Using green once here, then back to normal quickly, seems to make that
# problem not happen. Odd. 
# Anyway, do not remove this next block.
if [ ! "$*" = "-h" -a ! "$*" = "-v" ] ; then
  $SETCOLOR_SUCCESS
  echo .
  $SETCOLOR_NORMAL
  echo .
  note "$PROG version $SCRUBVER\nsuite version $SUITEVER"
fi

OS=`uname -s`
OSVERSION=`uname -r`
OPDATADISPLAY=:0.0
TCPDISPLAY=:0.0
DIALUP=ppp0
NOSHAREON=""

[ "$PUBLICETHER" ] || PUBLICETHER=eth0
[ "$PRIVATEETHER" ] || PRIVATEETHER=eth1
PUBLICIP=`ifconfig $PUBLICETHER 2>/dev/null | grep "inet addr" | tail -1 | awk '{print $2}' | sed 's/addr://g'`
PRIVATEIP=`ifconfig $PRIVATEETHER 2>/dev/null | grep "inet addr" | tail -1 | awk '{print $2}' | sed 's/addr://g'`

GEN3SITE="`cat /mnt/hgfs/host/site.txt 2>/dev/null`"
GEN3HOST="`cat /mnt/hgfs/host/host.txt 2>/dev/null`"
GEN3SCHEDULEID="`cat /mnt/hgfs/host/scheduleid.txt 2>/dev/null`"
GEN3OPTYPE="`cat /mnt/hgfs/host/dirty.txt 2>/dev/null`"

OPSCHEDULE=$GEN3SCHEDULEID

HOST="$GEN3HOST"
# Silently delete garbage characters, this is from user input
GEN3OPNAME="`cat /mnt/hgfs/host/opname.txt | tr 'a-z' 'A-Z' | tr -dc 'A-Z0-9_' 2>/dev/null`"
OLDSITE="`cat /site.txt 2>/dev/null`"

export PROJECTNAME SUITELOC GEN3 SUITENUM OLDSITE GEN3OPNAME GEN3SITE GEN3SUITE PRIVATEIP PUBLICIP PRIVATEETHER PUBLICETHER GEN3SCHEDULEID GEN3OPTYPE OPSCHEDULE

# Either of these two being true means we are on GEN3
[ "${PRIVATEIP:0:11}" = "192.168.254" ] && GEN3="$PRIVATEETHER address is $PRIVATEIP"
[ "$GEN3SITE$GEN3HOST$GEN3OPNAME" ] && GEN3="$PRIVATEETHER address is $PRIVATEIP host is $GEN3HOST and opname is $GEN3OPNAME"

[ ! $GEN3SITE ] && unset GEN3 && notered "You have an eth1 of 192.168.254, but no site.txt! We will assume this is NOT a GEN3 station!"


# GEN3 requirements
if [ "$GEN3" ] ; then
    if [ "`echo -n "$GEN3OPNAME" | tr -d 'a-zA-Z0-9_-' | grep -q .`" ] ; then
        notered "Invalid opname in /mnt/hgfs/host/opname.txt, can only contain a-z, A-Z, numbers, '_' and '-'."
        notered "Trying to fix that....new name is:\n     "
        GEN3OPNAME=`echo "$GEN3OPNAME" | tr -dc 'a-zA-Z0-9_-' `
        [ "$GEN3OPNAME" ] || notered exit The /mnt/hgfs/host/opname.txt file on this GEN3 station is corrupt. Restart your VM.
        if [ "`echo -n "$GEN3OPNAME" | tr -d 'a-zA-Z0-9_-' | grep -q .`" ] ; then
            notered "Could not fix the project name in /mnt/hgfs/host/opname.txt.\n"
            notered exit "You must restart this VM and reanswer the initial project name prompt."
        fi
        notered "\n\nPausing here for 15 seconds.  ^C and restart VM if this is not your project name:\n\n\t$GEN3OPNAME"
        sleep 15
    fi
    PROJECTNAME=$GEN3OPNAME
fi

ETHER=$PUBLICETHER


[ "$RIGHTDISPLAY" ] && TCPDISPLAY=$RIGHTDISPLAY

#OPDIR="." # NOT USING ANYMORE
TOOLS=bin
DOWN=down
TEXTS=etc
DOC=doc
UP=up
MAILDIR=mailpull
COMMANDSDIR=targetcommands

LOCALIPVAR=LOCALIP

if [ "$DEBUG" ] ; then
      echo "IN DEBUG MODE. CHANGING TOP=/tmp and INTERFACE=${PUBLICETHER}."
      TOP=/tmp
      INTERFACE=${PUBLICETHER}
      DIALUP=${PUBLICETHER}
fi


PLATFORM=`uname`
if [ "$PLATFORM" = "Linux" ]; then
  MINUSN=-n
else
  MINUSN=""
fi

DOUPGRADE=""
DOCHECKINS=always
DNSSERVERS=""
TESTGETOPDATA=""
TRACKERUPDATE=""
echo -n "$TRACKERMODULUS" | tr -d '0-9' | grep -q . || TRACKERUPDATE=$TRACKERMODULUS

if [ "$TRACKERUPDATE" ] ; then
    # Hardcode to 15 minutes or more
    [ $TRACKERUPDATE -gt 0 ] || TRACKERUPDATE=900
else
    TRACKERUPDATE=900
fi


# Default is now to ALWAYS unpack some ROUTER_* tarballs
RTRBALLS=ROUTER_[A-Z]*.[0-9]*.tar.bz2


TARBALL=""
USERAT="NOPEN"

rm -f /tmp/*.txt.mod

while getopts hvNum123456789sf:n:UGp:P:S:i:I:gFWXCtT:M: optvar ; do
  # process -args
  case "$optvar" in


  # -F, -C and -W: These are not in the usage, for testing purposes only
  F) echo -n "$OPTARG" | tr -d '0-9' | grep -q . || TRACKERUPDATE=$OPTARG
     [ $TRACKERUPDATE -gt 0 ] || TRACKERUPDATE=900
     note Used -F to set TRACKERUPDATE=$TRACKERUPDATE=
    ;;
  c) DOCHECKINS=""
     note Used -c to DISABLE autocheckin
    ;;
  C) DOCHECKINS="Via-C"
     note Used -C to set DOCHECKINS=$DOCHECKINS=
    ;;
  W) note "Used -W to set NOSHAREON to NO - who told you about this undocumented feature? Hmmmm"
     NOSHAREON=NOIMEANYESIMEAN--BOOM
    ;;


  v|h) usage exit -$optvar ;;
  X) USERAT="NONE";;
  g) GEN3="$PRIVATEETHER address is $PRIVATEIP Forced with scrubhands -g"
     note "Setting GEN3 to GEN3=\"$GEN3\"";;
  G) note "Building /tmp/$DATE/bin/getopdata and friends and then exiting (/current is unchanged)"
	TOP=/tmp
	DOUPGRADE="no"
	OPSCHEDULE=
	TESTGETOPDATA=yes ;;
  M) PALMTU=$OPTARG
	  [ "$OPTARG" = "`echo $OPTARG | tr -dc '0-9'`" ] || notered exit Invalid -M $OPTARG
	  [ "$OPTARG" -ge 500 ] || notered exit Invalid -M $OPTARG, too low
	  ;;
  N) note "Networking staying as-is:"
        ifconfig -a
        netstat -rn
        P=0
        LOCALNET=-N
        ;;
  I|i) 
       echo -n "$OPTARG" | tr -d "0-9" | grep -q . && \
	   notered exit "-I $OPTARG: Invalid USERID, must be all digits"
       TEST=`echo -n $OPTARG | wc -c`
       if [ $TEST != 5 ] ; then
	   notered exit "-I $OPTARG: Must be exactly five digits (use 11111 if you do not have one)"
       fi
       OPERID=$OPTARG
       OPUSER=$OPERID
       ;;

  P|p) 
       OPTARG=`echo $OPTARG | tr 'a-z' 'A-Z'`
       PROJECTNAME=$OPTARG
     ;;

  S) 
	if [ "${OPTARG:0:1}" = "F" ] ; then
	    OPTARG=99999999999999
	    note "Using a fake schedule ID of $OPTARG, fix later with \"-newsched\""
	fi
	echo -n "$OPTARG" | tr -d - | tr -d '0-9' | grep -q . && \
	   notered exit "-S $OPTARG: Invalid Op Schedule ID (must be 14 digits (dashes optional), YYMMDD########)"
	# Now removing dashes here also
	OPSCHEDULENEW=`echo "$OPTARG"| tr -dc "0-9"`
	[ "$OPSCHEDULE" ] || OPSCHEDULE=$OPSCHEDULENEW
	if [ "$OPSCHEDULE" != "$OPSCHEDULENEW" ]  ; then
	   notered "OPSCHEDULE=$OPSCHEDULE (from /mnt/hgfs/host/scheduleid.txt) does not match"
	   notered "OPSCHEDULENEW=$OPSCHEDULENEW (from -S option on command line)"
	   note "\n\nPlease enter the correct one:"
	   DEFAULTID=$OPSCHEDULENEW
	   [ "$DEFAULTID" ] || DEFAULTID=$OPSCHEDULE
	   ans=""
	   while [ ! "$ans" ] ; do
	       echo -en "\nSchedule ID? [$DEFAULTID] "
	       read ans
	       [ "$ans" ] || ans=$DEFAULTID
	       TEST=`echo -n "$ans" | tr -d "0-9-"`
	       if [ "$TEST" ] ; then
		   notered "ScheduleID must be 14 digits (dashes optional), yours includes \"$TEST\" in ans=\"$ans\""
		   ans=""
		   continue
	       fi
	       ans=`echo "$ans" | tr -dc "0-9"`
	       note ans=$ans=
	   done
	   OPSCHEDULE=$ans
	   [ "$GEN3SCHEDULEID" = "$OPSCHEDULE" ] || echo $OPSCHEDULE > /tmp/scheduleid.txt.mod
	   GEN3SCHEDULEID=$OPSCHEDULE
	fi
	unset DEFAULTID OPSCHEDULENEW
	;;

  T) echo -n "$OPTARG" | tr -d '0-9-' | grep -q . && \
        notered exit "-S $OPTARG: Invalid Room-Station (must be ##-##)"
     SUITEOPTION=$OPTARG
     SUITEOPTION=`echo "$SUITEOPTION" | grep "^[0-9][0-9]*-[0-9][0-9]*$"`
     if [ "$SUITEOPTION" ] ; then
	 note Pre-setting SUITE option to $SUITEOPTION
     else
	notered exit "-S $OPTARG: Invalid Room-Station (must be ##-##)"
     fi

     ;;

  n) echo -n "$OPTARG" | tr -d '0-9,.' | grep -q . && \
        notered exit "-n $OPTARG: Invalid DNS argument"
     DNSSERVERS=`echo "$OPTARG"| tr "," " "`
     NEWLINES=""
     for i in $DNSSERVERS ; do
	 NEWLINES="$NEWLINES\nnameserver $i"
	 (echo $i | grepip -q) || continue
	 notered exit Invalid DNS IP address $i
     done
     note "Replacing old resolv.conf (old one renamed to resolv.conf.replaced): "
     cat /etc/resolv.conf
     mv /etc/resolv.conf /etc/resolv.conf.replaced
     echo -e "$NEWLINES" > /etc/resolv.conf
     if [ $? -gt 0 ] ; then
	 notered exit Unable to modify /etc/resolv.conf
     fi
     note "With new resolv.conf containing:\n"
     cat /etc/resolv.conf
     ;;
  
  f) TARBALL=$OPTARG
    if [ ! -e $TARBALL ] ; then
	usage exit -f argument \"$TARBALL\" does not exist
    fi
    ;;

  U) note "SKIPPING upgrade of /usr/local/bin"
	DOUPGRADE="no"
	;;
  u) notered "Upgrading /usr/local/sbin from op and exiting"
	[ "$NEWPROG" ] && usage exit Cannot use -u with $NEWPROG
        DOUPGRADE=yes
        PROJECTNAME=NOTHING
	ColorsOff
        ;;
  m) note "Leaving ZIP mounted"
        LEAVEMOUNTED=yes
        ;;
  [1-9])
        NUM=`echo $1 | tr -d "-"`
        note "Taking $NUM most recent tarballs off of zip if there"
        TARSONZIP=$NUM
        ;;
  s) note "Skipping scripme.override file, if any"
     NOSCRIPME=yes ;;
  t) note "Get files using the FG method (no thumb). WARNING: presumes /usr/local/sbin was already updated, such as mz -s would do for you."
     FG=1
     FINDZIPOPTS="$FINDZIPOPTS -f" && FINDZIPOPTS=`echo $FINDZIPOPTS | sed 's/^.*\-/-/'` #set this var, trimming leading whitespace
     FGTEMP="$TOP/fg"
     ;;
  *)  usage exit "Argument not recognized: $1"        ;;
  esac
done
shift `expr $OPTIND - 1`


OPSCHEDULE=`echo -n "$OPSCHEDULE" | tr -dc "0-9"`
TEST2=`echo -n "$OPSCHEDULE" | wc -c`
if [ $TEST2 -ne 14 -a ! "$TESTGETOPDATA" ] ; then
    notered "OPSCHEDULE=$OPSCHEDULE: Invalid Op Schedule ID (must be 14 digits (dashes optional), YYMMDD########)"
    notered "You MUST fix this later with the NOPEN command\"-newsched YYMMDD########\""
    sleep 3
    notered "You MUST fix this later with the NOPEN command\"-newsched YYMMDD########\""
    sleep 3
fi

if [ "$PROJECTNAME" ] ; then
    # Both PROJECTNAME and GEN3OPNAME have already been uppercased as they were set.
    if [ "$PROJECTNAME" != "$GEN3OPNAME" ] ; then
	notered "GEN3OPNAME=$GEN3OPNAME (from /mnt/hgfs/host/opname.txt) does not match"
	notered "PROJECTNAME=$PROJECTNAME (from -P option)"
	note "\n\nPlease enter the correct project name, it will be used for both variables."
	ans=""
	while [ ! "$ans" ] ; do
	    echo -en "\nProject Name? "
	    read ans
	    [ "$ans" ] || notered You must answer with a project name
	    ans=`echo "$ans" | tr "A-Z" "a-z"`
	    note ans=$ans=
	    TEST=`echo "$ans" | tr -d "a-z0-9_-"`
	    if [ "$TEST" ] ; then
		notered "Project names can only contain: A-Z, numbers, \"-\" and \"_\", you included \"$TEST\" in ans=\"$ans\""
		note "(case insensitive)"
		ans=""
	    fi
	done
	PROJECTNAME=`echo "$ans" | tr 'a-z' 'A-Z' | tr -dc "A-Z0-9_-"`
	notered DBG: PROJECTNAME=$PROJECTNAME= ans=$ans=
	[ "$GEN3OPNAME" = "$PROJECTNAME" ] || echo $PROJECTNAME > /tmp/opname.txt.mod
	GEN3OPNAME=$PROJECTNAME
    fi
else 
    PROJECTNAME=$GEN3OPNAME
fi

echo -n "$PROJECTNAME" | tr -d 'a-zA-Z0-9_-' | grep -q . && \
  notered exit "Invalid -P option=$PROJECTNAME=, can only contain a-z, A-Z, numbers, '_' and '-'"


# Check that we are only running FG on GEN 3 for now
if [ "$FG" == 1  -a ! "$GEN3" ]  ; then
	notered exit "Cannot continue: Running FG mode not supported on < GEN 3 (for now)."
fi

SRCFILES=`dirname $0`/findzip	
if [ "$FG" == 1 ] ; then
	note "Running FG mode on a GEN 3 station (FG: $FG  GEN3: $GEN3) "
elif [ -n "$TARBALL" -o "$DOUPGRADE" != "yes" ] ; then
    for f in $SRCFILES ; do
	if [ ! -e "$f" ] ; then
	    notered exit REQUIRED file $f cannot be found
	fi
	. $f
    done
fi


if [ "$NEWPROG" ] ; then
    note "SKIPPING upgrade of /usr/local/bin"
    DOUPGRADE="no"
fi


[ -d $TOP ] || mkdir -p $TOP 2>/dev/null || echo -e "\aUNABLE TO \"mkdir -p $TOP\""
[ -d $TOP/$DATE/tmp ] || mkdir -p $TOP/$DATE/tmp 2>/dev/null || echo -e "\aUNABLE TO \"mkdir -p $TOP/$DATE/tmp\""

if [ `id -u` != 0 ] ; then
    notered You must be root
    exit 1
fi

# Now no more need to run this
tmpfixdeletelater

# /dev/sttun 20031204
[ -e /dev/sttun ] || mknod /dev/sttun c 10 64

# Make sure not another scrubhands running
TMP=`ps -efww | egrep "getopdata|tcpdump|script" | egrep -v "emacs|pcap.*tcpdump|grep|$$|$PPID|tcpdump -i.*unixdump|tcpdump -l -n -n -i .* ip|tcpdump.*defunct>"`
[ "$DEBUG" = "nocheck" ] && TMP=
[ "$TESTGETOPDATA" = "yes" ] && TMP=
if [ "$TMP" ] ; then
    notered "\n\nCannot proceed.($$) Following are already running (possibly another scrubhands?):\n\n"
    notered "$TMP"
    exit
fi
unset TMP

P=0
case $# in
  2)  usage exit -h "wrong number of arguments"
      ;;
  1)
      P=1
      if [ "`echo "$1" | grep "/"`" ] ; then
	PALIP=`echo $1 | sed "s,/.*,,g"`
	PALMASK=`echo $1 | sed "s,/[^\/]*$,,g" | sed "s,.*/,,g"`
	PALROUTER=`echo $1 | sed "s,.*/,,g"`
	echo $PALROUTER | grep -q "\." || PALROUTER=`echo $PALIP | sed "s/\.[0-9]*$//g"`.$PALROUTER
	if [ "$PALMASK" ] ; then
	    echo $PALMASK | grep -q "\." || PALMASK=255.255.255.$PALMASK
	fi
	[ "$PALMASK" = "$PALIP" ] && PALMASK=255.255.255.224
      else
	PALIP=${1}
	PALMASK=255.255.255.0
	PALROUTER=`echo ${PALIP} | sed "s%\([0-9]*.[0-9]*.[0-9]*\).[0-9]*%\1.1%"`
      fi
      if [ `which grepip 2>/dev/null` ] ; then
        if [ ! `echo $PALIP | grepip 2>/dev/null` ] ; then
          usage exit "Invalid IP Address: $PALIP"
        fi
        if [ ! `echo $PALMASK | grepip 2>/dev/null` ] ; then
          usage exit "Invalid IP mask: $PALMASK"
        fi
        if [ ! `echo $PALROUTER | grepip 2>/dev/null` ] ; then
          usage exit "Invalid IP for router: $PALROUTER"
        fi
      fi
      ;;
  3)
      P=1
      if [ `which grepip 2>/dev/null` ] ; then
        if [ ! `echo $1 | grepip 2>/dev/null` ] ; then
	  usage exit "Invalid IP Address: $1"
	fi
        if [ ! `echo $2 | grepip 2>/dev/null` ] ; then
	  usage exit "Invalid IP Netmask: $2"
	fi
        if [ ! `echo $3 | grepip 2>/dev/null` ] ; then
	  usage exit "Invalid IP Address for default router: $3"
	fi
      fi
      PALIP=${1}
      PALMASK=${2}
      PALROUTER=${3}
      ;;
esac


echo "Starting ${PROG} v.$SCRUBVER"


# Remove reboot lines from history files - backgrounded
histclean &

WIPETHESE="*.bz2 *.gz *.tar *.tgz */tn* */jl* */.keys* */*/opnotes.txt */opnotes.txt *-problems.txt oppasswd"

if [ "$TESTGETOPDATA" = "" ] ; then
    if [ ! "$DOUPGRADE" = "yes" ] ; then
      if [ "$GEN3" ] ; then
        [ ! "$PRIVATEIP" ] && notered exit "Cannot continue: Your GEN3 station has no $PRIVATEETHER address"
        [ "${PRIVATEIP:0:11}" != "192.168.254" ] && notered exit "Cannot continue: Your GEN3 station has a $PRIVATEETHER address ($PRIVATEIP) outside of 192.168.254/24"
      fi
#	echo "

#NOTICE: Now wiping subdirectories of $TOP/
#older than ten days.
#"
#	YEAR=`date +%Y`
#	MONTH=`date +%m`
#	DAY=`date +%d`
#	DAY=`expr $DAY - 10`
#	if [ $DAY -lt 1 ] ; then
#	    DAY=`expr $DAY + 30`
#	    MONTH=`expr $MONTH - 1`
#	    if [ $MONTH -eq 0 ] ; then
#		MONTH=12
#		YEAR=`expr $YEAR - 1`
#	    fi
#	fi
#	DAY=`expr 100 + $DAY`
#	DAY=${DAY:1:2}
#	MONTH=`expr 100 + $MONTH`
#	MONTH=${MONTH:1:2}
#	STOPDATE=${YEAR}${MONTH}${DAY}
#	
#	echo -en "\n\n# Wiping these directories (10+ days old starting with YYYYMMDD) via rm -rf: "
#	for DIR in `ls $TOP  | egrep "^[0-9]{8}"` ; do
#	    DIRDATE=${DIR:0:8}
#	    [ "$DIRDATE" -ge "$STOPDATE" ] && break
#	    echo -e "    ${DIR}"
#	    rm -rf $TOP/${DIR}
#	done
#	unset DIR STOPDATE DIRDATE DAY MONTH YEAR
#	echo "
#	
#NOTICE: Now wiping the following files & directories in
#every remaining directory in $TOP/.
#"
#	WIPEMORE=`find ${TOP} -type d -name varkeys`
#	if [ "$WIPEMORE" ] ; then
#	    echo "  rm -rf $WIPEMORE"
#	    rm -rf $WIPEMORE &
#	fi
#	for F in $WIPETHESE ; do \
#	    echo "  rm -rf ${TOP}/${F} ${TOP}/*/${F} ${TOP}/*/bin/*/${F} ${TOP}/*/up/*/${F} ${TOP}/*/op?/${F} ${TOP}/*/op?/*/${F}" ; \
#	done 
#
#	for F in $WIPETHESE ; do \
#	    rm -rf ${TOP}/${F} ${TOP}/*/${F} ${TOP}/*/bin/*/${F} ${TOP}/*/up/*/${F} ${TOP}/*/op?/${F} ${TOP}/*/op?/*/${F} ; \
#	done

	# Removing some state files if there
	note Removing these leftover state files and old myenv, if any:
	more `find  /root/.ssh* /root/.xispinfo /tmp/isp_info -type f 2>/dev/null` 2>/dev/null | cat
	rm -rvf /usr/local/bin/myenv /root/.ssh* /root/.xispinfo /tmp/isp_info 2>/dev/null 

	FREEBLKS=`stat -f $TOP --format=%a 2>/dev/null`
	TOTALBLKS=`stat -f $TOP --format=%b 2>/dev/null`
	BLKSIZE=`stat -f $TOP --format=%s 2>/dev/null`


	if [ "$FREEBLKS" ] ; then
	    PCTFREE=`echo 100*$FREEBLKS/$TOTALBLKS | bc`
	    MBFREE=`echo $BLKSIZE*$FREEBLKS/1024/1024 | bc`
	    echo "

$TOP has $MBFREE megabytes available, or $PCTFREE% free space

"
	    sleep 1
	    if [ $PCTFREE -lt 2 -o $MBFREE -lt 100 ] ; then
		echo ""
		df -k
		usage exit "FATAL ERROR: Not enough space  available"
	    fi
	else
	    echo -e "\aWARNING: Could not check free space - wrong version of \"stat\"?"
	    sleep 1
	fi
	if [ "$P" = "1" ]; then
	    if [ ! "$DNSSERVERS" ] ; then
		sed 's/^/#/g' /etc/resolv.conf > /tmp/resolv.conf 
		cp /tmp/resolv.conf /etc/resolv.conf 
	    fi
    

	    while [ 1 ] ; do 
	    #ifconfig $DIALUP down
	    #ifconfig $ETHER down
		netstat -rn | egrep "default|^0\.0\.0\.0" |awk '{print $2}' > /tmp/route
		sed 's/^/route -v delete default /g' /tmp/route > /tmp/delroutes
		if [ -s /tmp/route ] ; then
		    note red Deleting old default gateway: `cat /tmp/route`
		    /bin/sh /tmp/delroutes
		fi
		PINGED=""
		if [ "$PALIP" = "$PALROUTER" ] ; then
		    note red '\n\n\nINVALID NETWORK SETUP (your IP cannot equal your gateway)!!!\n\n\a'
		else
		    etherConfig ${PALIP} ${PALMASK} ${PALROUTER}
		    ping -nc1 $PALROUTER && break
		    PINGED=yes
		    note red '\n\n\nINVALID NETWORK SETUP!!!\n\n\a'
		fi
		sleep 1
		[ "$PINGED" ] && note 'A ping to your default router just failed.'
		note '\n\nPlease confirm/correct each of the following:'
		sleep 1
		echo -en "\n\n             What is your IP? [$PALIP] "
		read ans
		[ "$ans" ] && PALIP=$ans
		echo -en "\n\n        What is your netmask? [$PALMASK] "
		read ans
		[ "$ans" ] && PALMASK=$ans
		echo -en "\n\nWhat is your default gateway? [$PALROUTER] "
		read ans
		[ "$ans" ] && PALROUTER=$ans
	    done
	    rm -f /tmp/route /tmp/delroutes
	    
	    echo
	    echo -e "To reconfigure the network, run\n\n"
	    echo "etherConfig ${PALIP} ${PALMASK} ${PALROUTER}"
	    echo
	    INTERFACE=$ETHER
	else
	    if [ "$LOCALNET" = "-N" ]; then
		INTERFACE=$ETHER
	    else
		INTERFACE=$DIALUP
	    fi
	fi
    fi
fi
if [ "$PALMTU" ] ; then
    note Setting $INTERFACE MTU to $PALMTU with: ifconfig $INTERFACE mtu $PALMTU
    ifconfig $INTERFACE mtu $PALMTU
    ifconfig $INTERFACE | grep -q MTU:$PALMTU || notered exit FAILED: scrubhands failed to run ifconfig $INTERFACE mtu $PALMTU
    ifconfig $INTERFACE
    note Set $INTERFACE MTU to $PALMTU with: ifconfig $INTERFACE mtu $PALMTU
fi

unset WIPEMORE FREEBLKS TOTALBLKS BLKSIZE PCTFREE MBFREE


LOCALIP=`ifconfig $INTERFACE 2>/dev/null | grep "inet addr" | tail -1 | awk '{print $2}' | sed 's/addr://g'`

#until [ ! "$DOUPGRADE" -o "$LOCALIP" ] ; do
if [ ! "$DOUPGRADE" = "yes" ] ; then
  WAITONIP=0
  until [ "$LOCALIP" ] ; do
    if [ "`which phone 2>/dev/null`" -a "$INTERFACE" = "ppp0" ] ; then
      $SETCOLOR_WARNING
      echo "You have no IP address on $INTERFACE: "
      $SETCOLOR_NORMAL
      if [ "$DEBUG" ] ; then
        debug=1
        TOP=/tmp
        INTERFACE=${PUBLICETHER}
      else
	if [ $WAITONIP -gt 0 ] ; then
	    note "Dialing now...Waiting on IP"
	    WAITCOUNT=0
	    FAILCOUNT=0
	    # Three ways out of this until:
	    # 1) We get an IP and drop out and play
	    # 2) We go a full 180 seconds and wvdial/pppd never resolve an IP
	    # 3) We go a consecutive 15 seconds with no setupisp/wvdial/pppd, so likely
	    #    it aint coming back
	    while [ 1 ] ; do
		WAITCOUNT=$((WAITCOUNT + 1))
		sleep 1
		LOCALIP=`ifconfig $INTERFACE 2>/dev/null | grep inet | tail -1 | awk '{print $2}' | sed 's/addr://g'`
		if [ "$LOCALIP" ] ; then
		    WAITONIP=0
		    WAITCOUNT=180
		    break
		fi
		MYTEST=`ps -efwwwwww | egrep -v "vim|emacs|less|more|grep" | egrep "phone|setupisp|wvdial|pppd"`
		if [ "$MYTEST" ] ; then
		    FAILCOUNT=0
		else
		    FAILCOUNT=$((FAILCOUNT + 1))
		    if [ $FAILCOUNT -gt 3 ] ; then
			notered "wvdial/pppd seem to have died or not started. Trying again."
			break
		    fi
		fi
	    done
	    unset WAITCOUNT
	    if [ $WAITONIP -gt 0 ] ; then
		notered "\n\nABORTING: No IP $INTERFACE address for too long."
		notered "          You can try again.\n\n"
	    else
		# We have IP, so break out of until [ "$LOCALIP" ]
		break
	    fi
	else
	    ifconfig -a
	fi
        echo -n "Choose one of the following:

	1) call phone start to dial out via ppp
	2) use existing networking (a la \"${PROG} -N\")
	3) bring up fresh $TERM to configure network then proceed with #2
	4) bail completely

Your choice: [1] "
        read ans
        [ "$ans" ] || ans=1
	ans=${ans:0:1}
        case $ans in
        3|2)
	  if [ "$ans" = "3" ] ; then 
	      echo -n "Use the new $TERM to configure the network.
Exit it when done..."
	      xargs="-display :0 +cm +cn -sk -sb -sl 15000 -fg black -bg white"
	      $TERM $xargs -geometry 80x55+1276+0 -title "CLOSE WHEN NET IS CONFIGURED"
	  fi
	  # here's the #2 part
          ifconfig -a
          netstat -rn
          P=0
          LOCALNET=-N
	  INTERFACE=$ETHER
	  ;;
        1)
	  echo -n "phone start popping up in other window now..."
          phone start
	  INTERFACE=ppp0
	  WAITONIP=1
          sleep 1
  
	  ;;
        4)
          usage exit "BAILING"
	  ;;
        *)
          continue
          ;;
        esac
  
      fi
      LOCALIP=`ifconfig $INTERFACE 2>/dev/null | grep inet | tail -1 | awk '{print $2}' | sed 's/addr://g'`
    else
      notered "You have no IP address on $INTERFACE! (and \"phone\" is not in path)"
      echo "Fix your path or run one of:
      ISP_start
      phone start
      lan start
      "
      echo "Maybe \"${PROG} -h\" will help.
      "
      exit 1
    fi
  done
  unset WAITONIP

    unalias ls 2>/dev/null
    alias xt='$TERM -ls +cn -sk -sb -sl 5000 -e bash&'
    alias ll='ls -al'
    alias lt='ls -alrt'
fi

while [ 1 ] ; do
    if [ ! -d $TOP/$DATE ]; then                   
	    mkdir -p $TOP/$DATE/tmp
	    echo "`date` Starting scrubhands v.$SUITEVER with: $CALLEDAS" >> $TOP/$DATE/tmp/dammit
	    if [ ! "$TESTGETOPDATA" ] ; then
		echo "Using $INTERFACE with IP $LOCALIP"
		rm -f /last.current.3
		mv /last.current.2 /last.current.3
		mv /last.current.1 /last.current.2
		mv /last.current.0 /last.current.1
		mv /current        /last.current.0
		ln -s $TOP/$DATE /current
		ls -ld /current $TOP/$DATE /current && note "/current is now a link to  $TOP/$DATE"

	    else
		note exit wtf TESTGETOPDATA=$TESTGETOPDATA=
	    fi
	    break
    else
	    echo $MINUSN "Directory $TOP/$DATE already exists--moving it to .oldN"
	    EXT=1
	    while [ -d $TOP/$DATE.old$EXT ] ; do
		EXT=`expr $EXT + 1`
	    done
	    mv $TOP/$DATE $TOP/$DATE.old$EXT
    fi
done

mkdir -pv $TOP/$DATE/$DOWN/SCREEN_CAPTURE/ $TOP/DONE $TOP/$DATE/$TOOLS \
	 $TOP/$DATE/$DOWN/PACKET_CAPTURE_DATA/ \
	 $TOP/$DATE/$DOWN/cmdout/html $TOP/$DATE/$DOWN/NOSEND \
	 $TOP/$DATE/$DOWN/$MAILDIR/nogood

cd $TOP/$DATE/$DOWN



# The next block creates several files on the op machine,
# including perl executables, some of which are 
# customized for this op.
#
# NOTE: Within this perl code, a $ without a \ is going to be
#       handled by the bash script itself as a bash variable.
#       To allow the perl script created to use it as a variable,
#       it must appear here as \$variable. Similarly, any backticks
#       used within the perl code must be escaped or the bash
#       script will execute the code inside the ticks.
#

# Since scrubhands is now maintaining copy-what, we want to be sure
# we wipe any on the Desktop, linking them instead to script
# in /usr/local/bin.
if [ -x /usr/local/bin/copy-what ] ; then
    note "Fixing ~/Desktop/copy-* to point to /usr/local/bin/copy-what"
    # We do this in subshell so cd is not permanent
    (   cd ~/Desktop
        rm -f copy-*
        ln -sf /usr/local/bin/copy-what copy-ds
        ln -sf /usr/local/bin/copy-what copy-slow
        ln -sf /usr/local/bin/copy-what copy-fast
        ln -sf /usr/local/bin/copy-what copy-emerg
        ln -sf /usr/local/bin/copy-what copy-egg
	cd /usr/local/bin
	rm -f copy-{fast,slow,emerg,egg}
        ln -sf copy-what copy-ds
        ln -sf copy-what copy-slow
        ln -sf copy-what copy-fast
        ln -sf copy-what copy-emerg
        ln -sf copy-what copy-egg

        cd $TOP/$DATE/bin
        rm -f copy-{slow,fast,emerg,egg}
        [ -f copy-what ] || ( rm -f copy-what ; cp -p /usr/local/bin/copy-what . )
        ln -sf copy-what copy-ds
        ln -sf copy-what copy-slow
        ln -sf copy-what copy-fast
        ln -sf copy-what copy-emerg
        ln -sf copy-what copy-egg
    )
fi

cd $TOP/$DATE/$DOWN

# NEW: Force either projectname or scheduleID defined sooner, before zip even mounted
if [ ! "$TESTGETOPDATA$OPSCHEDULE" -a ! "$DOUPGRADE" = "yes" ] ; then
    ans=""
    notered "\n\n\nSCHEDULE ID:\nTo avoid this prompt, use the -S YYMMDD######## ScheduleID option."
    while [ ! "$ans" ] ; do
	note "\n\nSchedule ID must be 14 digits starting with YYMM.\n\n"
	echo -en "\nSchedule ID? "
	read ans
	[ ! "$ans" ] && continue
	TEST=`echo "$ans" | tr -d "0-9"`
	TEST2=`echo "$ans" | tr -d '\n-' | wc -c`
	if [ $TEST2 -ne 14 -o "$TEST" ] ; then
	    notered "You must answer with a valid Schedule ID (YYMMDD########)"
	    note "(14 digits)"
	    ans=""
	else
	    OPSCHEDULE=`echo $ans | tr -d '-'`
	fi
    done
    if [ ! "$PROJECTNAME" ] ; then
	ans=""
#	notered "\n\n\nPROJECTNAME:\nTo avoid this prompt, use either the -P PROJECTNAME option."
	while [ ! "$ans" ] ; do
	    echo -en "\nProject Name? "
	    read ans
	    [ "$ans" ] || notered You must answer with a project name
	    ans=`echo "$ans" | tr "A-Z" "a-z"`
	    TEST=`echo "$ans" | tr -d "a-z0-9_-"`
	    if [ "$TEST" ] ; then
		notered "Project names can only contain: A-Z, numbers, \"-\" and \"_\", you included \"$TEST\" in ans=\"$ans\""
		note "(case insensitive)"
		ans=""
	    else
		PROJECTNAME=`echo "$ans" | tr -dc "a-z0-9_-"`
	    fi
	done
    fi
    [ "$OPSCHEDULE" ] || OPSCHEDULE=UNKNOWN
fi

note "Creating $TOP/$DATE/$TOOLS/ethwarn.pl and /usr/local/bin/ethwarn"
# For ppp*, we do not want to show only our own IP
if [ ! ${INTERFACE:0:3} = "ppp" ] ; then
  LOCALIP=`ifconfig $INTERFACE 2>/dev/null | grep inet | grep -v "127\.0\.0\.1" | head -1 | awk '{print $2}' | sed 's/addr://g'`
  [ "$LOCALIP" ] && HOSTSTR="host $LOCALIP and "
fi

cat <<ETHWARN > $TOP/$DATE/$TOOLS/ethwarn.pl
#!/usr/bin/env perl
#\`rm -f /tmp/filters.old /tmp/filters ; mv /tmp/filters.inuse /tmp/filters.old 2>/dev/null\`;
open(TCPIN , "/usr/sbin/tcpdump -i $INTERFACE -l -n '${HOSTSTR}((tcp[13] & 7 != 0) or (not tcp))' |");
#another option would be
#open(TCPIN , "/usr/sbin/tcpdump -i $INTERFACE -l -n '(net not 10/8) and (net not 192.168/16) and ((tcp[13] & 7 != 0) or (not tcp))' |");
\$red="\033[1;31m";
\$blue="\033[1;34m";
print "Output of $TOP/$DATE/$TOOLS/ethwarn.pl:

tcpdump -i $INTERFACE -l -n '${HOSTSTR}(tcp[13] & 7 != 0) or (not tcp)'
\$blue
NOTE: 
      Use Ctrl-middle-button and turn on visual bell in this window to disable the beep but still bring this window to the front.

      To filter out some traffic output, put regular expressions matching the output for those packets into /tmp/filters. (note these are not
      parameters to tcpdump--the RE's put here mean lines from the existing running tcpdump that match will NOT be echoed.) Once ethwarn.pl reads in
      the filters you give, it stops showing those lines and renames the file to /tmp/filters.inuse. To add another filter, use:

	    echo \"<new filter>\" >> /tmp/filters.inuse && mv /tmp/filters.inuse /tmp/filters

      New filters will be put in place with the next packet seen by the original tcpdump filters. Once the filters are read in, you will see the
      complete set of filters in use echoed here.

      To change to a different tcpdump command (e.g. to add 'net not 10/8'), edit your /current/bin/ethwarn.pl script to suit, and then run
      /usr/local/bin/ethwarn (which calls /current/bin/ethwarn.pl in a fresh $TERM). At that point, you can kill the first ethwarn.pl window.
\$red
";
@filters = ();
%filters = ();
if (-e "/tmp/filters.inuse") {
  sleep 2; # make sure it is done growing
  if (open(FILTERSIN, "/tmp/filters.inuse")) {
    while ( chomp(\$t = <FILTERSIN>) ) {
      \$filters{\$t}++;
    }
    close(FILTERSIN);
  }
}
@filters = keys %filters;
tcpin: while (<TCPIN>) {
  # see if this file exists if so start the filters from scratch 
  # using those entries (lines matching the RE's in this file are skipped)
  if (-e "/tmp/filters") {
    open(FILTERSIN, "/tmp/filters") ;
    while ( chomp(\$t = <FILTERSIN>) ) {
      \$filters{\$t}++;
    }
    unlink("/tmp/filters");
    close(FILTERSIN);
    @filters = keys %filters;
    open(FILTERSOUT, "> /tmp/filters.inuse") ;
    print "\n\$blue
NOW FILTERING OUT:
==================\n";
    foreach (@filters) {
      print FILTERSOUT "\$_\n";
      print "\$_\n";
    }
    close(FILTERSOUT);
    print "=======================\n\$red\n";
  }
  foreach \$skip ( @filters ) {
    next tcpin if ( /\$skip/ );
  }
  # we want the bell on every line of output so the -pob argument of
  # the $TERM to follow brings it to the front when we get a hit.
  print "\a\$_";
}
ETHWARN

cat <<ETHWRN > /usr/local/bin/ethwarn
#!/bin/sh
$TERM -vb +pob +cm +cn -sk -sb  -hold -sl 15000 -bg white -fg Red \
  -name 'SYN/FIN/RST and non-TCP PACKETS' -title 'SYN/FIN/RST and non-TCP PACKETS' \
  -display $TCPDISPLAY -geometry 200x14-0-165 \
  -e /current/bin/ethwarn.pl &
ETHWRN
chmod 755 /usr/local/bin/ethwarn  $TOP/$DATE/$TOOLS/ethwarn.pl

cd $TOP/

note Creating $TOP/$DATE/$TOOLS/doupgarde
cat <<DOUPGRADE > $TOP/$DATE/$TOOLS/doupgrade
#!/usr/bin/env perl
# This script generated by $PROG $SUITEVER. 
#
# upgrade /usr/local/sbin copy of a few files to one in ./bin
system("touch $TOP/$DATE/bin/doupgrade.done");
#use Time::HiRes qw( sleep );
\$debug="$DEBUG" ;
@upgradables = (
        "alwayspcap.pl","blockme",      "clocksync.pl", "copy-what",
	"doublet",	"ethcheck",	"etherConfig",	"ethernetMACs.txt",
        "fg.py",
	"findzip",      "fw_setup.pl",  "fwrules.py",
        "ftshell",	"getopnotes",
	"grepip",	"initialize",   "lsstamp",
	"mergetargets", "mkfinds",	"mkoffset",	"mkrandom",	"ourtn",
	"packrat",	"parsescan",	"promptkill",	"pschain",	"radlast",
	"scanner",
	"scripme",	"scripme.pl",	"scriptcheck", 
	"${PROG}",	"sendopnotes", "setupisp",	"tnmunger",	"whatrat.pl",
	"whl"
);

print "\n\nThis script generated by $PROG $SUITEVER.\n";

print "\n\n\${COLOR_NOTE}Looking for new copies of ".scalar @upgradables." tools: \$COLOR_NORMAL\n\n";
for (\$i = 1 ; \$i < scalar @upgradables; \$i+=3 ) {
  printf("\t%-20s %-20s %-20s\n",\$upgradables[\$i-1],\$upgradables[\$i],\$upgradables[\$i+1]);
}
while (scalar @files < 15) {
  @files = split(/\n/,\`ls -al $TOP/$DATE/bin\`) ;
  sleep 3 ;
}
sleep 2 ;

\$destdir="/usr/local/sbin/" ;
\$newdir="$TOP/$DATE/$TOOLS/" ;
print "\n
File                Old Version   New Version\n
----                -----------   -----------\n";
foreach \$file (@upgradables) {
    if (\$file =~ /txt\$/) { 
      if ( -e "\$newdir/\$file" ) {
        print "\${COLOR_SUCCESS}Forcing upgrade of .txt file.\$COLOR_NORMAL\n";
      } else {
        next ;
      }
    } else {
	(\$newver,\$newverval) = &verval(\$newdir,\$file);

	unless (\$newver) {
	    printf("%-20s   NOT IN THIS TARBALL\n",\$file);
	    next ;
	}
	(\$oldver,\$oldverval) = &verval(\$destdir,\$file);
	printf("%-20s     %-9s     %-7s\n",\$file,\$oldver,\$newver);
	if (\$oldverval and \$oldverval > \$newverval) {
	    print "\n\n\${COLOR_FAILURE}Op box has newer \$file than your op disk!!  YOU SHOULD REBUILD YOUR OP.\n\n\a";
	    sleep 2;
	    print "\n\n\${COLOR_FAILURE}Op box version \$oldverval  >  \$newverval!  YOU SHOULD REBUILD YOUR OP.\n\n\a";
	    sleep 2;
	    print "\n\n\${COLOR_FAILURE}Op box has newer \$file than your op disk!!  YOU SHOULD REBUILD YOUR OP.\n\n\$COLOR_NORMAL\a";
	    sleep 2;
	    # If not same version, copy existing \$destdir one into op dir--do not want older version anywhere.
	    print \`cp -p \$mvv \$destdir/\$file \$newdir\`;
	    next;
	} elsif (\$oldverval and \$oldverval eq \$newverval) {
	    next;
	}
    }
    print "\${COLOR_SUCCESS}Installing new \$file, version \$newver...\$COLOR_NORMAL\n";
    \$c = 1;
    while (-e "\$destdir/\$file.old\$c") {
      \$c++;
    }
    print \`mv \$mvv \$destdir/\$file \$destdir/\$file.old\$c\` unless ( \$file =~ /txt\$/ ) ;
    print \`cp -p \$mvv \$newdir/\$file \$destdir\`;
    \`chmod 755 \$destdir/\$file\`;
    \`chmod 644 \$destdir/\$file\` if ( \$file =~ /txt\$/ ) ;
    print \`ls -alrt \$destdir/*\$file* | tail -4 \`;
    if ( \$file =~ /$PROG/ ) {
	print "\n\n\${COLOR_FAILURE}JUST UPGRADED ${PROG}!!  You must re-run your $PROG command.\n\n\a";
	sleep 2;
	print "\n\n\${COLOR_FAILURE}JUST UPGRADED ${PROG}!!  You must re-run your $PROG command.\n\n\a";
	sleep 2;
	print "\n\n\${COLOR_FAILURE}JUST UPGRADED ${PROG}!!  You must re-run your $PROG command.\n\n\a";
	sleep 2;
    }
}
print "\n\n\${COLOR_SUCCESS}Done upgrading /usr/local/bin/\n\n";
if (-e "\$newdir/rpc" and \`diff \$newdir/rpc /etc/rpc 2>&1\` ) {
  print "\n\n\${COLOR_NOTE}Upgrading /etc/rpc from \$newdir/rpc\$COLOR_NORMAL\n\n";
  \$c = 1;
  while (-e "/etc/rpc.old\$c") {
    \$c++;
  }
  print \`mv \$mvv /etc/rpc /etc/rpc.old\$c\` ;
  print \`mv \$mvv \$newdir/rpc /etc/rpc\` ;
}

if ("$INTERFACE" eq "$ETHER") {
  print "\n\nUsing $ETHER, so setting clock via clocksync.pl since phone start not used\n\n";
  # We run this here since setupisp will not be run when using ethernet
  # which is the other place it gets called.
  if ( -x "/usr/local/bin/clocksync.pl") {
    system("/usr/local/bin/clocksync.pl -e");
  }
}

print "\n\nWiping /current/bin/scrubhands so later runs not confused\n\n";
unlink("/current/bin/scrubhands");

print "\n\n\${COLOR_NOTE}You may now exit this window.\n\$COLOR_NORMAL\n";
print "\n\n\${COLOR_FAILURE}Brought to you by scrubhands v$SUITEVER\n\$COLOR_NORMAL\n";
sleep 1 ;

sub verval {
  local(\$execdir,\$execfile) = @_ ;
  local(@tmp,@runs,\$vernum,\$verstr,\$runthis,\$pid,\$tmp,\$count,\$parm);
  my \$tmpfile = "/tmp/tmpver.scrub.$$" ;
  my \$delay = 100000 ;

  \$runthis = "\$execdir/\$execfile" ;
  if ( -x "\$runthis" ) {
    unlink("\$tmpfile");
    # run program with these parameters dumping output into \$tmpfile
    @runs = ("-v","-h","");
    foreach \$parm (@runs) {
      \$delay = 100000 ;
      \$count = 0;
      \$pid = fork();
      # fork in case kid never dies naturally with this parameter
      if (! \$pid ) {
	print "DBG: RUNNING: \$runthis \$parm 2>&1 | egrep -i \"version[ .]*[0-9.]|v[ .]*[0-9.]*\\\$\" >> \$tmpfile\n" if \$debug ;
        exec "\$runthis \$parm 2>&1 | egrep -i \"version[ .]*[0-9.]|v[ .]*[0-9.]*\\\$\" >> \$tmpfile" ;
        exit ; 
      }
#      sleep 0.1;
      \`usleep \$delay 2>/dev/null\` ;
      # look for kid not dying, kill after 0.4 seconds, kill -9 after 1.5 secs
      while (\$tmp = \`ps -ef | egrep \$pid | grep -v grep | grep -v defunct\`) {
        \$count++;
#        sleep 0.1;
        \`usleep \$delay 2>/dev/null\` ;
        if ( \$count > 8 ) {
          kill (HUP,\$pid);
          \$delay += 250000;
        }
        kill (9,\$pid) if ( \$count > 15 );
	if (\$count > 80) {
	  warn "\${COLOR_WARNING}
WARNING: Hmm...Can't seem to kill \$pid after 8 seconds...
         stranding it and continuing...

         PLEASE: Cut and paste content of this window into
         /current/down/killproblem
$\{COLOR_NORMAL}" ;
         \`echo "SH: killproblem on \$pid with \$runthis \$parm (ps -ef in opnotes.txt)" >> $TOP/$DATE/$DOWN/opnotes.txt\`;
	 \`ps -efwwwww >> $TOP/$DATE/$DOWN/opnotes.txt\`;
          last ;
        }
      }
      # no need to go on if got version in \$tmpfile
      last if (-s "\$tmpfile") ;
    }
    # final entry of this ought to be version string
    @tmp = split (/[\s]/,myreadfile(\$tmpfile)) ;
    unlink(\$tmpfile);
  }
  print "DBG: Got \@tmp=(@tmp) on \$runthis\n" if \$debug ;
  chomp (\$verstr = pop(@tmp));
  \$verstr =~ s/[a-z]//gi ;
  @tmp = split (/\./, \$verstr);
  if (@tmp == 2) {
    # Nevermind about x.x.x.x we have n.m, use this value
    return(\$verstr,\$verstr);
#   # Convert #.# into #.0.0.#
#   @tmp = ($tmp[0],0,0,$tmp[1]);
  }
  # process ver string with multiple dots (no one rev greater than 9999 please)
  \$vernum = shift(@tmp) + 1000 ;
  my \$frac = -1 ;
  while (@tmp) {
    \$frac++ ;
    if (\$frac > 0) {
      \$vernum = \$vernum + (shift(@tmp)/(1000**\$frac));
    } else {
      \$vernum = 1000 * \$vernum + shift(@tmp);
    }
  }
  print "DBG: returning (\$vernum,\$verstr)\n" if \$debug;
  return () unless \$verstr ;
  return (\$verstr,\$vernum) ;
} # end sub verval
sub myreadfile {
    if (defined &readfile) {
        return readfile(@_);
    }
    my \$val = "";
    foreach my \$outfile (@_) {
	if (-s \$outfile and open(SCRUBIN,\$outfile)) {
	    while (<SCRUBIN>) {
		\$val .= \$_;
	    }
	    close(SCRUBIN);
	}
    }
    return \$val;
}
#myreadfile should not be needed?

DOUPGRADE
chmod 700 $TOP/$DATE/$TOOLS/doupgrade

note Creating  $TOP/$DATE/$TOOLS/getopdata

cat <<GETOPDATA > $TOP/$DATE/$TOOLS/getopdata
#!/usr/bin/env perl
# This script generated by $PROG v.$SCRUBVER at $DATE

\$VER="$SCRUBVER";

#use Time::HiRes qw( sleep );
use File::Basename qw(basename dirname);
use File::Copy ;

my \$datedir = "$DATE";
my \$topdate = "$TOP/$DATE";
my \$top = "$TOP";
my \$gotutils = "\$topdate/etc/autoutils" ;

my \$optcount = 0;
\$logfile = "/tmp/getopdatalog";

if (-s \$gotutils ) {
    do \$gotutils; # Populates gbl_externalIP{"current"}

    die("bad option(s)") if ((! Getopts( "hvt:s:u:V:TMOSHP" )) and
        (! \$opt_h)) ;    
    \$optcount++ if \$opt_H;
    \$optcount++ if \$opt_O;
    \$optcount++ if \$opt_P;
    \$optcount++ if \$opt_S;
    \$optcount++ if \$opt_T;
    \$optcount++ if \$opt_V;
    \$viascrubhands = "@ARGV" =~ /viascrubhands/i ;
    \$viacopywhat = shift @ARGV if (\$ARGV[0] =~ /(viacopy-\S+)/i) ;
    \$viascrubhands = shift @ARGV if (\$ARGV[0] eq "viascrubhands") ;

    docommandline(); # May not return

    # In scrubhands, these uppercase variables WITHOUT an escape on the \$ are either defined
    # or they are not, so in getopdata, the strings are either fixed constants or empty.
    newhostvar("gbl_opproject",\$projectnamelower)
        if (!\$gbl_opproject and \$projectnamelower and \$projectnameupper ne "NOTHING");
    newhostvar("gbl_opschedule","$OPSCHEDULE")
        if (!\$gbl_opschedule and "$OPSCHEDULE" and "$OPSCHEDULE" ne "UNKNOWN");
    newhostvar("gbl_opuser","$OPERID")
        if (!\$gbl_opuser and "$OPERID" and "$OPERID" ne "UNKNOWN");
}

if (!\$viascrubhands and lc \$ARGV[0] eq "setvar") {
    # USAGE:  At command line:
    #        getopdata setvar varname [host] value of var
    #
    # host option puts content in hostvars.\$nopen_rhostname if that is defined.
    # To set hashed arrays, use a "." for each bracket, both { and }, in varname.
    shift(@ARGV);
    die "$TOP/$DATE/etc/autoutils not there or valid\n"
        unless (require "$TOP/$DATE/etc/autoutils");

    my \$type = "gbl_";
    my \$varname = shift(@ARGV);
    if (\$varname =~ /.*\\..*\\.\$/) {
      \$varname =~ s,(.)\\.,\\1\\{,;
      \$varname =~ s,\\.$,\\},;
    }
    \$varname =~ s,\.,_,g;
    my \$value = gmtime()."\\t";
    foreach my \$arg (@ARGV) {
        if (lc \$arg eq "host") {
          if (\$nopen_rhostname) {
            \$type = "host_";
          }
        } else {
          \$value .= " \$arg";
        }
    }
    die "Usage:  At command line:

           getopdata setvar varname [host] [value of var]

Optional host argument puts content in hostvars.nopen_rhostname if that
is defined. To set hashed arrays, use a \\".\\" for each bracket in varname.

getopdata v. $SCRUBVER
" unless (\$varname and \$value and not \$varname =~ m,-,);
    \$value .= " OPSCHEDULE=\$gbl_opschedule" if \$gbl_opschedule;
    newhostvar("\$type\$varname","\$value");
    die "getopdata just set:\n\n\\\$\$type\$varname = \\"\$value\\"\n";
}



# unlink(\$logfile) if \$viascrubhands; # NO, not deleting here. This op's logfile will have some of the last op tail end (after tarball packed up) in it.

die "CANNOT WRITE TO LOGFILE \$logfile: \$!\n"
    unless open(LOG,">> \$logfile");
print LOG "\\n\\n".gmtime()." NEW OP BEGGINNING\\n\\n";
close(LOG);

printboth("This getopdata was created by ${PROG} v.$SCRUBVER at $DATE.\\n\\n")
    unless (@ARGV or -f "/tmp/.getopdatathere");

\$ans = "";
my \$waitcount=1;
my \$getopver = "$SUITEVER";
my %aliasedip = ();
\$freshstep_contents = "";
\$tracker_updates_sent = 0;
\$nonstandard = 0;
\$specialproc = 0;
\$successful = "";
\$oplength = 0;
\$minindented = -1;


%locs = ();
\$locnum = 0;
# We give these sites numbers in this order, i.e. \$locs{North} will be 1, etc.
foreach my \$name (
    "North",
    "South",
    "East",
    "West",
    "North-new",
    "South-new",
    "East-new",
    "West-new",) {
  \$locnum++;
  \$locs{ucfirst \$name} = \$locnum;
  \$locs{\$locnum} = \$locnum;
}


# If this is gone, perhaps they are re-running getopdata after aborting
# an earlier attempt. Default to unique match if one, otherwise tell them
# to fix it. NO AUTOUTILS FUNCTIONS YET, but scrubhands (all uppercase
# without the dollar sign escaped) variables are OK.


if (-d \$topdate) {
    \$ENV{DATE} = \$datedir;
} else {
    printboth("This getopdata started its life in \$topdate which no longer exists\\n")
        unless (-f "/tmp/.getopdatathere");
    @newdirs = split(/\n/,\`cd \$top ; ls -d1 \$datedir* 2>&1 | grep -v "\.old" | tee -a \$logfile\`);
    if (@newdirs == 1) {
        \$ENV{DATE} = \$newdirs[0];
        \$datedir = \$newdirs[0];
        printboth("\\n\\nUsing \$topdate instead\\n\\n")
            unless (-f "/tmp/.getopdatathere");
    } else {
      printboth("\\n\\nABORTING!!\\n");
      sleep 1;
      printboth("\$COLOR_FAILURE");
      printboth("\\n\\nABORTING!!\\n");
      sleep 1;
      printboth("\$COLOR_NORMAL");
      printboth("\\n\\nABORTING!!\\n\\n\\nRearrange things in \$top so only one entry starts with \$datedir\\n\n");
      sleep 1;
      die "\\n\\nRearrange things in \$top so only one entry starts with \$datedir\\n";
    }
    unlink("/current");
    symlink("\$topdate","/current");
}


# These are set by any call to freshsteptracker
\$suite = "\$ENV{SUITENUM}";
\$genthree = "$GEN3";
\$genthreesite = "$GEN3SITE";
\$genthreehost = "$GEN3HOST";
\$suite = "$SUITENUM" if "$SUITENUM";
\$ethprivaddr = "$PRIVATEIP";
\$ethpubaddr = "$PUBLICIP";
\$originaltargets = "";
\$modifiedtargets = "";

\$projectnamelower = lc "$PROJECTNAME";
\$projectnameupper = uc \$projectnamelower;


if (\$projectnamelower and \$projectnameupper ne "NOTHING") {
    newhostvar("gbl_opproject",\$projectnamelower);
    newhostvar("gbl_project",\$projectnamelower);
}
newhostvar("gbl_opschedule","$OPSCHEDULE")
    if ("$OPSCHEDULE" and "$OPSCHEDULE" ne "UNKNOWN");
opproject("$GEN3OPNAME")
    if ("$GEN3OPNAME");
newhostvar("gbl_genthreesuite","$GEN3SUITE")
    if ("$GEN3SUITE");
newhostvar("gbl_genthreesite","$GEN3SITE")
    if ("$GEN3SITE");
newhostvar("gbl_genthreehost","$GEN3HOST")
    if ("$GEN3HOST");

if (\$genthree) {
  # Reset these from files if they are there
  chomp(my \$tmpsuite = myreadfile("/root/suiteloc.txt"));
  \$suite = \$2 if (\$tmpsuite =~ /((\d+)-\d+)/);
  if (\$tmpsuite) {
    \$genthreesuite = \$tmpsuite;
  }

  chomp(my \$tmpsite = myreadfile("/mnt/hgfs/host/site.txt")) ;
  if (\$tmpsite) {
    \$genthreesite = \$tmpsite;
  }
  chomp(my \$tmphost = myreadfile("/mnt/hgfs/host/host.txt"));
  \$genthreehost = \$tmphost if (\$tmphost =~ /\d+/ and ! \$genthreehost);
}


if (\$viascrubhands or "@ARGV" eq "") {
    unlink("/tmp/.getopdatathere");
}

while (!(\$viacopywhat or -f "/tmp/.getopdatathere") and \$waitcount++) {
    print gmtime()." Waiting for tarball to finish unpacking...\\n"
        if (\$waitcount < 2 or !(\$waitcount % 10));
    sleep 1;
    last if -s "\$topdate/etc/autoutils" and -s "\$topdate/etc/autogetinput" ;
}

do \$gotutils; # Populates gbl_externalIP{"current"}



printboth("\nJust sourced \$gotutils:\n".\`ls -al \$gotutils\`);

# Set the gbl_suiteinfo global at top and bottom of op
newhostvar("gbl_suiteinfo","\$suite/\$ethprivaddr")
  if (\$suite or \$ethprivaddr);
my \$val = myreadfile("/tmp/suiteinfo","/suite.txt");
if (\$val) {
  newhostvar("gbl_suiteinfofile",\$val);
}



printboth("\nSuite/Location information: suite=\$suite genthreesuite=\$genthreesuite gbl_suiteinfo=$gbl_suiteinfo= genthree=$genthree=\n");
#printboth("\nSuite/Location debug/RC information: GEN3=$GEN3 \n");


roomlookup(); # Sets some \$gbl_s also

newhostvar("gbl_suite",\$suite)
    if (\$suite > 0);
newhostvar("gbl_internalIP","$PRIVATEIP");


# Check if one in /ulb is different than one in ./etc, if so upgrade it
my \$binfile = "/usr/local/bin/autoutils";
if ("$DOUPGRADE" ne "no" and -e \$binfile) {
    chomp(my \$binver = \`grep "autoutilsver.*=.*\$autoutilsver" \$binfile\`);
    unless (length \$binver > 5) {
        (\$binver) = \`grep autoutilsver.*=.*v \$binfile\` =~ /\\"(.*)\\"/;

        printboth("\n\nUpgrading \$binfile (v.\$binver) from \$topdate/etc/autoutils (v.\$autoutilsver)\n\n") ;
        preservefile(\$binfile);
        copy("\$topdate/etc/autoutils",\$binfile);
    }
}
\$vertext = "\$prog version \$getopver using autoutils \$gotutils version \$autoutilsver\\n\\n" ;



unless (-f "/tmp/.getopdatathere") {
    # Sleep an extra 2 seconds to give tarball more time to unpack
    sleep 2;
    printboth(gmtime()." Got it! Scrubhands has populated \$topdate/etc/autoutils, etc.\\n\\n".
       \`ls -al \$gotutils \$topdate/etc/autoutils | tee /tmp/.getopdatathere\`.
       "\\n\\n".
       "\$vertext"
    );
    sleep 1;
}

# set this if mv has verbose argument
if (\`mv --help 2>/dev/null | grep -- --verbose\`) {
  \$mvv = "-v";
} else {
  \$mvv = "";
}

#hard code vi
#if (-x "$EDITOR") {
#  \$editor = "$EDITOR";
#} else {
  \$editor = "vim";
#  \$editor = "vim  -c \\\\\":set textwidth=0\\\\\" ";
#}
printboth("Now\$COLOR_FAILURE AUTO GENERATING\$COLOR_NORMAL content of ispinfo.txt.

NEW      NEW      NEW      NEW      

SEVEN prompts have been eliminated here.

\$COLOR_NORMAL


");
\$host=\$ENV{'HOST'};
if (! \$host ) {
  chomp( \$host = \`hostname\`);
}
\$host = uc \$host;

\$localip= "$LOCALIP" ;
\$redirectip = "none" ;
\$redirecttype = "$REDIRECTTYPE" ;
\$redirecttypes{"none"} = 1;
\$redirectabbrevs{"PA"} = "PALLIAL";
\$redirectabbrevs{"PI"} = "PITCHIMPAIR";
\$redirectabbrevs{"IN"} = "INCISION";
\$redirectabbrevs{"LA"} = "LAZYPINCH";
foreach (keys %redirectabbrevs) {
  \$redirecttypes{\$redirectabbrevs{\$_}} = 1;
}


&getispinfo();

my \$fwsetupprog = "/usr/local/bin/fwrules.py";

# This is better if it is there
\$fwsetupprog = "\$topdate/$TOOLS/fwrules.py" if (-x "\$topdate/$TOOLS/fwrules.py");

# This FWUSERUSER variable allows testing of the new way for only those
# with a password until we know we all have one.
my \$fwuseuser = "user";
if (defined \$ENV{FWUSEUSER} and \$ENV{FWUSEUSER} =~ /^\d{5}$/) {
    \$fwuseuser = \$ENV{FWUSEUSER}
} else {
    newhostvar("gbl_fwuser","user");
}

# REMOVE THIS LINE TO REMOVE THE FORCED -U user LATER ONCE WE WANT TO:
\$fwsetupprogargs = " -U \$fwuseuser";

while (! -e \$fwsetupprog) {
    &getinput("\\n\\n\$fwsetupprog not yet there....\\n\\n".
              "Hit enter when you think it will be...");
}


# In scrubhands, these uppercase variables WITHOUT an escape on the \$ are either defined
# or they are not, so in getopdata, the strings are either fixed constants or empty.
newhostvar("gbl_opproject",$projectnamelower)
    if (!\$gbl_opproject and \$projectnamelower and \$projectnameupper ne "NOTHING");
newhostvar("gbl_opschedule","11111111111114")
    if (!\$gbl_opschedule and "$OPSCHEDULE" and "$OPSCHEDULE" ne "UNKNOWN");
newhostvar("gbl_opuser","73275")
    if (!\$gbl_opuser and "$OPERID" and "$OPERID" ne "UNKNOWN");


# opuser() sets \$gbl_opuser and \$gbl_oppasswd gobals
opuser("",1,\$gbl_opuser); # 2nd arg ==> no password yet, 3rd arg: Default userid
@opusers = (\$gbl_opuser);



my \$fwcmdup = "\$fwsetupprog \$fwsetupprogargs -s";
my \$fwcmddown = "\$fwsetupprog \$fwsetupprogargs -c";
(\$fwsetupver) = \`\$fwsetupprog -v 2>&1\` =~ /v{0,1}\D+([\d\.]+)/;
(\$fwsetupverstr,\$fwsetupverval) = verval(\$fwsetupver);

my \$fwcmdupnopasswd = "";
if (\$fwsetupprog eq "/usr/local/bin/fw_setup.pl" and
    \$fwsetupverval >= (verval("2.0.0.0"))[1] and \$gbl_oppasswd) {
    # Change to new \$fwsetupprog syntax once that is firmed up
    \$fwcmdup = "\$fwsetupprog -u \$gbl_opuser -p \$gbl_oppasswd -i \$pitchip";
    \$fwcmdupnopasswd = "\$fwsetupprog -u \$gbl_opuser -p xxx -i \$pitchip";
} elsif (\$fwsetupverval >= (verval("1.2.0.0"))[1]) {
    if (\$gbl_oppasswd) {
        \$fwcmdup = "\$fwsetupprog -s \$fwsetupprogargs -P \"\$gbl_oppasswd\"";
        \$fwcmdupnopasswd = "\$fwsetupprog \$fwsetupprogargs -P \"\xxx\"";
    } else {
        \$fwcmdup = "\$fwsetupprog -s \$fwsetupprogargs";
        \$fwcmdupnopasswd = "\$fwsetupprog -s \$fwsetupprogargs";
    }
}

my \$fwcmdresetatend = \$fwcmdup;
my \$fwcmdresetclock = \$fwcmdup;
my \$fwcmdresetatendnopasswd = \$fwcmdupnopasswd;
\$fwcmdresetatend =~ s, -s, -c -t 1m,;
\$fwcmdresetclock =~ s, -s, -p -t 5h,;
\$fwcmdresetatendnopasswd =~ s, -s, -c -t 1m,;

my \$moreprompt = "";
\$moreprompt = " (\$gbl_opuser)"
    if (\$gbl_opuser > 0);


### Ask for the target IP to connect to directly
printboth("

You may want to add a PITCHIMPAIR IP to allow through the firewall that you
will directly connect to. If you do not, ourtn can do it for you later.

");
my \$ipmore = "to skip and allow ourtn to make the needed fwrules changes";
my %allowedips = ();

while (1) {
  \$ans = &getinput("\nEnter IP to allow, or any line containing that IP, or hit Enter \$ipmore:", "");
  my \$origans = \$ans;
  \$ipmore = "if done entering IPs";
  last   if (\$ans eq "");
  (undef,\$ans) = \$ans =~ /(^|\D)(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})($|\D)/;
  unless(ipcheck(\$ans)) {
    printboth("YOUR ANSWER:\n\$origans\n".
            "\n\$COLOR_FAILURE\n\nYour answer does not contain a valid IP!\$COLOR_NORMAL\n");
    sleep 2;
    next;
  }
  \$allowedips{\$ans}++;
}
my (\$s,@allowedips) = ("",sort keys %allowedips);
\$s = "s" if (@allowedips > 1);
my \$esp = ",\nespecially for more than one IP"
  if (\$s);
my \$iplist = join("\n     ",@allowedips);
printboth("\n\nDONE entering IPs we will touch directly...be\$COLOR_FAILURE SURE\$COLOR_NORMAL\n".
        "these IPs are INITIAL REDIRECTORS (^C and start over if they are not):\n\n     ".
        \$iplist.
        "");
### Set up our gateway's firewall
printboth("

\$COLOR_FAILURE


          NOTE: Our firewall rules, both on this host and on our gateway, default to DROP
          any traffic not specifically allowed by IP. The fwrules.py script can be used to
          adjust those hosts that we allow.

          Note that to modify the rules on the gateway, it needs to send a username and password.
          Eventually, that will be your op USER ID (\$gbl_opuser) and a unique password. For now,
          though, you can answer \"user\" and the password can be avoided.

");


# don't pipe to tee b/c might need to ask for password if they mistyped above in the opuser() call.
system(\$fwcmdup);

# Run this again, can take out if we figure out why we need to and fix that.
printboth("\n\n\n\$COLOR_FAILURE".
    "\n\nRunning AGAIN (workaround, not sure why we need to): \"\$fwcmdupnopasswd\"\n\n");

system(\$fwcmdup);

# Delay 2 seconds here so child and parent both of \$fwcmdup have sent STDOUT.
sleep 2;

checklocalip(); # (Re-)Populates gbl_externalIP{"current"}

printboth("IP\$s being allowed:\n     \$iplist\n\n".
        "Be patient, sending the IP\$s to the firewall can take a while\$esp. You should see packets to the gateway in your ethwarn window.");
foreach my \$allowedip (@allowedips) {
  printboth("\n\nRunning \"\$fwsetupprog -A \$allowedip\"...\n\n");
  if(system("\$fwsetupprog \$fwsetupprogargs -A \$allowedip | tee -a \$logfile")) {
    printboth(
            "\$COLOR_FAILURE   ERROR RUNNING \$fwsetupprog \$COLOR_NORMAL\n\n".
            "\n\nUnable to run \"\$fwsetupprog\"...could be any of these problems:\n");
    printboth("   Is python in your PATH?\n");
    printboth("   Is the tarball still unpacking?\n");
    sleep 2;
  }
}

system("\$fwsetupprog \$fwsetupprogargs -p | tee -a \$logfile");
printboth("\nNOTE: run \"\$fwsetupprog\" in a scripted window to add/remove rules later\n");


printboth("\n\nThe OP tarball made by this script will contain data from the

        \$topdate/$DOWN*

directory(ies), after first moving into 
  \$topdate 
any directories starting with the following:

");
@gunks = (junk, gunk, foo, dum, blah, duh);
foreach (@gunks) {
  printboth("\t\$_");
}
printboth("

NOTE: No need to zip up your tcpdump file. Please put mail into 

                ../$DOWN/$MAILDIR/hostname.IPADDRESS/.

Once Op begins and ISP data is entered, a window will pop up to save
OP DETAILS in opnotes.txt as the op progresses.
");

if (!  fork() ) {
#  child's only job is to wait for opnotes.txt to appear, then bring
#  it up in an editor
#
# oldway: 
#  system("$TERM -name OP-DETAILS -title \"OP-DETAILS\" -display $TCPDISPLAY -geometry 80x45-0+30 -e \$editor +/^REM \$topdate/$DOWN/opnotes.txt");
#  while (! -e "\$topdate/$DOWN/opnotes.txt")  {
#    sleep 4;
#  }


  \$ratline="";
  if ("$USERAT" ne "NOPEN") {
    \$ratline="NS.RAT=$USERAT";
  }

  mydo("autoproblem","-O","\$gbl_opuser"," initiated op");
  open(OPINFOOUT,">> \$topdate/$DOWN/opnotes.txt") or warn "COULD NOT OPEN opnotes.txt";
  print OPINFOOUT "

BEGIN UNIX OPNOTES:

Targets (IP, full domain name, target tags: pitchimpair unsuccessful not_attempted ) : 



Results:

PROJECT=$PROJECTNAME
OPUSER=\$gbl_opuser
OPSCHEDULE=\$gbl_opschedule
SCRUBVER=$SCRUBVER
\$ratline


# Un-comment these as needed to mark as a non-standard / unsuccessful
#Non-Standard: True
#Op Status: Unsuccessful

####
# Lines to assist in techsums
# NOTEs and ERRORs will automatically generate a techsum
# You can also enclose any portion of your opnotes in a
# <TECHSUM></TECHSUM> block to have that section be included in
# the techsum automatically.  Like so:
# <TECHSUM>
# Bad things happened.
# Then more bad things happened.
# Then it _really_ got bad.
# </TECHSUM>
#  Please keep the <TECHSUM> and </TECHSUM> on separate lines
####

# Any lines entereed here at any point during the op that start
# with \"SH:\" will automagically be submitted as ${PROG} problems.
# So put them here as you think of them. Same with using NOPEN's
# -problem
# 
#                  Thanks.       -mgt
# 
#
#";
  close(OPINFOOUT);
  sync;
  exec("$TERM -name  OP-DETAILS -title \"OP-DETAILS\" -display $TCPDISPLAY -geometry 105x55+1920+26 -e \$editor +/\# \$topdate/$DOWN/opnotes.txt");
  
#  system("gvim +/^REM \$topdate/$DOWN/opnotes.txt");
#  exit;
}
        printboth("\\n\\nPLEASE SCRIPT YOUR TCPDUMP WINDOW NOW!!!!!!!\\n\\n");

  \$count = 0;
  until (-e "\$topdate/$DOWN/tcpdump.raw") {
    sleep 2;
    \$count += 2;
    unless (\$count % 120) {
      my \$date = \`date -u\` ;
      chomp(\$date) ;
      printboth("\\n\\n\$date: Still waiting for\\n\\n\\t\$topdate/$DOWN/tcpdump.raw");
      printboth("\\n\\nto be created. Did you forget to run these:\\a\\n");
      printboth("\\n\\tcd \$topdate/$DOWN\\n");
      printboth("\\t/usr/bin/script -af tcpdump.raw\\n") ;
    }
  }

\`chmod 700 $TOP/$DATE/etc/auto* $TOP/$DATE/etc/*pl 2>/dev/null\`;


if (\$gbl_opstarttime > 0) {
    \$starttime = \$gbl_opstarttime;
    \$startdate = \$gbl_opstartdate;
} else {
    \$starttime = time();
    \$startdate = timestamp(short);
    \$startdate =~ s,-.*,,;
    newhostvar("gbl_opstarttime",\$starttime,
               "gbl_opstartdate",\$startdate,
               "gbl_opstarttimestr",scalar gmtime(),
        );
}

#if ("$OPSCHEDULE" and "$OPSCHEDULE" ne "UNKNOWN") {
    #freshsteptracker("start","$OPSCHEDULE");
#} else {
#NEVER MIND: We always want project now
    freshsteptracker("start",lc \$projectnamelower);
#}

## List of targets/hostnames/projects...not really needed anymore
my \$waitisdone = 0;
my \$trackerupdatesent = \$gbl_opstarttime;
my \$otherupdatesent = \$gbl_opstarttime;
my \$otherupdateinterval = 900;
while (! \$waitisdone) {
  (\$activecount,\$stillactive,@stillactive,) = (0,0);

  (\$ethprivaddr) =
    \`ifconfig $PRIVATEETHER | grep inet.addr\` =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s/ ;
  (\$ethpubaddr) =
    \`ifconfig $PUBLICETHER | grep inet.addr\` =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s/ ;


  my \$trackerupdateinterval = int("0$TRACKERUPDATE");

  my \$updatemore = "";
  my \$trackerupdateintervalstr = secstostr(\$trackerupdateinterval);
  if (\$trackerupdateinterval > 0) {


    \$updatemore = "\ngetopdata will send periodic updates (every \$trackerupdateintervalstr) for op tracker.";
  }

    printboth("Your Suite Location: \$suite/\$ethprivaddr


When OP is completely done and the OP DETAILS editor and all scripted windows closed, getopdata will offer to pack up the op.
\$updatemore

Now looping...every TRACKERUPDATE=$TRACKERUPDATE seconds we send a tracker update

");

  newhostvar("gbl_suiteinfo","\$suite/\$ethprivaddr") if (\$ethprivaddr and \$suite);
  newhostvar("gbl_internalIP","\$ethprivaddr") if (\$ethprivaddr);
  if (\$ethpubaddr){
    my \$time = gmtime();
    my \$time2= time();
    newhostvar("gbl_externalIP{current}","\$ethpubaddr");
    newhostvar("gbl_externalIP","\$ethpubaddr at \$time \$time2");
  }


  # We loop here, every TRACKERUPDATE=$TRACKERUPDATE seconds (if > 0) we send a tracker update
  my \$loopstarttime = time();
  my \$lastfwreset = time();
  while (! \$waitisdone) {

    (\$activecount,\$stillactive,@stillactive,) = (0,0);
    sleep 8;

    ### We now automatically reset FW here every 148 minutes
    if (\$fwcmdresetclock and
	((time() - \$lastfwreset)/60 >= 148)) {
        printboth("Resetting timer on gateway FW to 5h with:    \$fwcmdresetclock\n\n".
          "");
        system(\$fwcmdresetclock);
        \$lastfwreset = time();
    }

    \$stillactive = 
      \`ps -ewwwwwf | egrep "script|scripme|opnotes.txt" | egrep -v "grep|tcpdump"\`;
    \$stillactive =~ s,(vim )(.*opnotes),vi \$1,g;
    @stillactive = split(/\n/,\$stillactive);
    \$activecount = @stillactive;
    my \$shorter = substr(\$stillactive,0,500);
    my (\$s,\$is) = ("","is");
    if (\$activecount > 1) {
       (\$s,\$is,\$es) = ("s","are","es");
    }

    \$shorter =~ s,\n[^\n]*\$,\n,;
    \$shorter = \$stillactive if (\$activecount < 4);
    # Never mind worrying about end of op in first 2 minutes
    if (((time() - \$gbl_opstarttime) > 70) and @stillactive and (\$activecount < 5)) {
        printboth("\$COLOR_FAILURE\n\n".
            "There \$is \$activecount process\$es still active, including:\$COLOR_NORMAL\n".
            "\$shorter\n\n".
            "If you are done with the op, you need to investigate/find/close/kill these."
            );
    } elsif (((time() - \$gbl_opstarttime) > 70) and ! \$activecount) {

         my \$cvjftest = \`ps -efwwwww | grep -v grep | egrep "[0-9] tar [cvjzf-]+ .*bz2"\`;

         if (\$cvjftest) {
            \$ans = &getinput
                 ("\n\nACTIVE tar cvjf COMMAND:\n\n\n".
                  \$cvjftest.
                  "\n\nYou should likely allow that to complete before you continue.\n\n".
                  "Are you sure you want to continue? [NO]");
            next unless \$ans =~ /^\s*y/i;
         }

         my \$more = "";
         # Call this now to get latest info
         discoverips("\$topdate/$DOWN/opnotes.txt","OP MAY NOW BE DONE quiet");
         foreach (keys %gbl_externalIP) {
            if (ipcheck(\$_)) {
             \$more .= "    \$_\n";
            } elsif (ipcheck(\$gbl_externalIP{\$_})) {
             \$more .= "    \$gbl_externalIP{\$_}\n";
            }
         } 
         \$more = "PUBLIC IPs USED:\n\$more"
             if \$more;
         if (\$gbl_modifiedtargets) {
             \$more .= "\n\nTargets thus far in Unix Opnotes:\n\$gbl_modifiedtargets\n\n";
         } elsif (\$gbl_targets) {
             \$more .= "\n\nTargets thus far in Unix Opnotes:\n\$gbl_targets\n\n";
         }
        \$opmegs = int(0.50 + (bwsofar())[0]);
        \$ans = &getinput
            ("\n\n".'=' x 200 . "\$COLOR_NORMAL\n\n".
            "Your scripts and the opnotes.txt editor are all gone.\n\n".
            \$more.
            "Op Bandwidth: \$opmegs M\n\n".         
            "Are you done with the op (if not, script a window to avoid this prompt)?","N");
        if (\$ans =~ /^\s*Y/i) {
          \$waitisdone++ if (\$ans =~ /^\s*Y/i);
          last;
        }
    } elsif (\$activecount < 5) {
         # Op is under 70 secs old and nothing scripted yet.
        printboth("\n\nACTIVE WINDOWS:\n".
                  \$stillactive.
                  "\n\nOp began at " . gmtime(\$gbl_opstarttime) . ", it's now ".scalar gmtime(). ".\n".
                  "There are hardly any scripted windows, but it's early yet. You must be very busy.")
	    if ((time() % 30) < 8);
    }


    # Once we turn on \$trackerupdateinterval we can get rid of this if/elsif and have just one block
    my \$dotracker = (\$trackerupdateinterval > 0 and 
                     (time() - \$trackerupdatesent > \$trackerupdateinterval)) ? 1 : 0;

    my \$doother = (\$otherupdateinterval > 0 and 
                     (time() - \$otherupdatesent) > \$otherupdateinterval) ? 1 : 0;

    if (\$dotracker or \$doother) {
        \$trackerupdatesent = time()
            if (\$dotracker);
        \$otherupdatesent = time()
            if (\$doother);
        # Some stuff we do regardless of which interval we just hit
        checklocalip(); # (Re-)Populates gbl_(inter|exter)nalIP{"current"}
        newhostvar("gbl_opmegs",int(0.50 + (bwsofar())[0]));
        \$opmegs = \$gbl_opmegs;
        
        discoverips("\$topdate/$DOWN/opnotes.txt","TRACKERUPDATE quiet");

#        # How old is opnotes.txt?
#        my \$secsold = -M "\$topdate/$DOWN/opnotes.txt" * 24 * 60 * 60 + time() - \$gbl_opstarttime;
#        my \$secsoldstr = secstostr(\$secsold);
#        my \$populatealso = "";
#        \$populatealso = " populate the Targets section of your opnotes.txt and"
#            unless (\$modifiedtargets);
#        if (\$secsold > \$otherupdateinterval or \$secsold > \$trackerupdateinterval) {
#            printboth("\$COLOR_FAILURE\n\n".
#                      "\n".

#                      "You should$populatealso save your opnotes.txt more often.\n".
#                      "It has not been saved for \$secsoldstr (\$secsold seconds).\n".
#                      "\n".

#                      "\$COLOR_NORMAL".
#                      "\n".
#                      "\n".
#                      "");
#        }

        # The tracker update we only do when it hits
        if (\$dotracker) {
            my \$more = "";
            if ((time() - \$loopstarttime) % 600 < 8) {
                \$more = ", NAMELY:\n\$stillactive";
            }
            dbg("sending tracker update at opmegs=\$opmegs and targets=\n$modifiedtargets with \$activecount ops windows still active\$more");
            freshsteptracker("update",\$projectnamelower) unless \$waitisdone;
        }
    }
  }

  if (my \$newval = myreadfile("/tmp/.newinterval")) {
    \$newval =~ s,\D,,g;
    unless (\$newval > 299) {
        \$trackerupdateinterval = int(\$newval);
        my \$minstr = secstostr(\$newval);
        unlink("/tmp/.newinterval");
        printboth("\n\nYour TRACKERUPDATE is now every \$minstr\n\n");
    }
  }
}

my \$oldschedule = \$gbl_opschedule ;

while (\$gbl_opschedule eq "99999999999999") {
      my \$new = getinput("You started with a fake schedule ID--please enter the actual ID now: ");
      next if (\$gbl_opschedule =~ /\D/ or
		(length \$gbl_opschedule != 14));
      newhostvar("gbl_opschedule",\$new);
}

unless (\$oldschedule eq \$gbl_opschedule) {
	printboth("Fixing opnotes.txt also:\n\nBEFORE:\n".
		  \`grep -4 SCHEDULE= \$opdown/opnotes.txt\`.
		  \`sed -e "s,^OPSCHEDULE=[0-9]*$,^OPSCHEDULE=\$gbl_opschedule,g" < \$opdown/opnotes.txt > \$opdown/opnotes.txt.\$\$ ; mv -v \$opdown/opnotes.txt.\$\$ \$opdown/opnotes.txt\`.
		  "\n\nAFTER\n".
		  \`grep -4 SCHEDULE= \$opdown/opnotes.txt\`);
}

# Kill the tcpdump.*ttt, the script -af and the xterm popup running it all
printboth("\n\nKilling scripted TCPDUMP window:\n\n");
my (\$killpid,\$killstr) = ();
unlink("/tmp/.pstmp");

\$killstr = \`ps -efwww | egrep -v "bash|xterm|grep" | egrep "tcpdump -n -n -tttt -i" | tee -a /tmp/.pstmp\`;
(\$killpid) = \$killstr =~ /(\d+)/;
printboth("    Killing \$killpid");
kill TERM,split(/\s+/,\$killpid);
sleep 1;

\$killstr = \`ps -efwww | egrep -v "bash|xterm|grep" | egrep "script -af tcpdump.raw" | tee -a /tmp/.pstmp\`;
(\$killpid) = \$killstr =~ /(\d+)/;
printboth("    Killing \$killpid");
kill TERM,split(/\s+/,\$killpid);

\$killstr = \`ps -efwww | egrep -v "bash|grep" | egrep "TCPDUMP" | tee -a /tmp/.pstmp\`;
(\$killpid) = \$killstr =~ /(\d+)/;
printboth("    Killing \$killpid");
kill TERM,split(/\s+/,\$killpid);
printboth("Done killing tcpdump:\n".\`cat /tmp/.pstmp\`);

unlink("/share/down/hostvars.global") ;
copy(\$global_varfile,"/share/down/hostvars.global") ;
\`chmod a=rw /share/down/hostvars.global\`;


if (open(OUT,">> \$topdate/down/scrubhands.log")) {
  print OUT "###################\\n".
            "SCRUBHANDS v${SCRUBVER} (suite v${SUITEVER} run in \$suite/\$ethprivaddr) command line:\\n:\\n".
            "###################\\n".
            "${CALLEDAS}\\n".
            "###################\\n";
} else {
  warn "unable to open \$topdate/down/scrubhands.log to append $0 command line" ;
}
close(OUT) ;

# save this with op, generated by clocksync.pl
if (-e "/tmp/clocksync.log") {
  \`cp /tmp/clocksync.log \$topdate/down/clocksync.log 2>/dev/null ; cat /tmp/clocksync.log 2>/dev/null >> \$logfile\`;
#  rename("/tmp/clocksync.log","\$topdate/clocksync.log");
  if ("\`grep FAIL /tmp/clocksync.log 2>/dev/null\`") {
    \`cat /tmp/clocksync.log 2>/dev/null >> /\$topdate/.moreSHerrors\`;
    unlink("/tmp/clocksync.log");
  }
}

unless (\$ans eq "redial" ) {
  \$ans     = &getinput("Did you have to redial the ISP? ","N");
  \$ans = "redial" if ( \$ans =~ /^y/i );
}
if (\$ans eq "redial" || \$ans0 eq "redial") {
  &getispinfo("redial");
}
\$more = "";
\$more = " additional" if (\`grep "^SH:" \$topdate/$DOWN/opnotes.txt\`);
\$ans     = &getinput("Did you have any\$more problems with or suggestions for ${PROG} or any other tools to report? ","N");
if (! open(OUT,">> \$topdate/$DOWN/${PROG}-problems.txt") ) {
  printboth("HUH? Could not open \$topdate/$DOWN/${PROG}-problems.txt.
   Report problems via another channel, including this error.\\a\\n\\n\\n");
} else {
  if ( \$ans =~ /^y/i ) {
    printboth("Enter your problems here, terminate with ^D on a new line.\\n\\n");
    printboth("> ");
    while ( <STDIN> ) {
      print OUT ;
      printboth("TO ${PROG}-problems.txt:$_");
      printboth("> ");
    }
    printboth("\\n\\n");
  }
  close(OUT) ;
}

#TODO: insert here logic that looks in tcpdump to try to guess our 
#RAT client/server ports -- can also look in opscript.txt
#then put in opnotes.txt

\`/usr/local/bin/mkzipdev 2>&1 | tee -a \$logfile\` if (-x "/usr/local/bin/mkzipdev") ;
chdir("\$topdate");
\$moved ="";
foreach (@gunks) {
  \$moved .= \`find . -type d -name "\$_*"\`;
}

if (\$moved) {
  printboth("Relocating the following to \$topdate so not in tarball:\\n\\n");
  @newnames = split (/\\n/,\$moved);
  foreach (@newnames) {
    next if (/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/) ;
    \$old = \$_;
    s%\$top\/\$datedir%%g;
    s/\//~/g;
    s/^\.//g;
    print \`mv \$mvv \$old \$topdate/\$_ 2>&1 | tee -a \$logfile\`;
  }
}

foreach (
         "\$topdate/$DOWN/opnotes.txt.pregetopdata",
         "\$topdate/$DOWN/opinfo.txt.additional",
         "\$topdate/$DOWN/opnotes.txt.additional",
         "\$topdate/$DOWN/problems.log",
         ) {
    if (open(MORE_IN,"< \$_")) {
        printboth("\\n\\nPutting contents of \$_ into /\$topdate/$DOWN/opnotes.txt\\n\\n");
        my \$prob = "" ;
        \$prob = "SH: " if ( /problems.log/ ) ;
        if (open(OPINFOOUT,">> /\$topdate/$DOWN/opnotes.txt" )) {
            print OPINFOOUT "\\n\\n\${prob}ADDITIONAL opinfo from \$_\\n\${prob}\\n" ;
            while (\$tmp = <MORE_IN>) {
              print OPINFOOUT "\$prob\$tmp";
            }
            print OPINFOOUT "\$prob\\n";
            close(OPINFOOUT) ;
        }
        close(MORE_IN) ;
#        unlink("\$_");
    }
}

if (open(SH_IN,"< /\$topdate/.moreSHerrors" )) {
  print OUT "SH: \$_" while (<SH_IN>) ;
  close(SH_IN) ;
}

\`grep "^SH:" \$topdate/down/opnotes.txt >> \$topdate/$DOWN/${PROG}-problems.txt 2>/dev/null \`;
\`echo "\$host: scrubhands v. $SCRUBVER \$datedir" >> \$topdate/$DOWN/opnotes.txt\`;
if (-s "\$topdate/$DOWN/${PROG}-problems.txt") {
  if (open(GETOPOUT,">>\$topdate/$DOWN/${PROG}-problems.txt")) {
    print GETOPOUT  "SH: \$host: $SCRUBVER \$datedir\n".
        "SH: SH OPUSER=\$gbl_opuser v$SCRUBVER local \$host: \`uname -a\`\n".
        \`more /etc/*ease | sed \"s/^/SH: /g\"\`;

    close(GETOPOUT);
  } else {
    \`echo "SH: \$host: $SCRUBVER \$datedir" >> \$topdate/$DOWN/${PROG}-problems.txt\`;
    system("echo SH: SH v$SCRUBVER local \$host: \`uname -a\` >> \$topdate/$DOWN/${PROG}-problems.txt");
    system("more /etc/*ease | sed \"s/^/SH: /g\" >> \$topdate/$DOWN/${PROG}-problems.txt");
  }
  newhostvar("gbl_gotproblems",\`ls -al \$topdate/$DOWN/*problems.txt \$topdate/$DOWN/*problems.log 2>/dev/null\`);
} else {
    unlink("\$topdate/$DOWN/${PROG}-problems.txt");
}
#\$donethishost{"HOSTNAME"}++ ;
#unless (\$donethishost{\$host}) {
#}

\`egrep -v "^REM |^\#" \$topdate/$DOWN/opnotes.txt > /tmp/t.$$ && mv /tmp/t.$$ \$topdate/$DOWN/opnotes.txt\`;
\`cp /\$topdate/$DOWN/opnotes.txt /\$topdate/$DOWN/opnotes.txt.prevalidation\` ;

#if ( \$listener ) {
#  \$port = 9999;
#  while ( ! ( \$dolistener =~ /^[yn]/i ) ) {
#    \$dolistener=        &getinput("
#Do you want to start a netcat listener on port
#\$port to dump the contents of:
#\$topdate/$DOWN/opnotes.txt? ","N");
#    if ( \$dolistener =~ /^y/i  ) {
#      if (\$tmp = fork()) {
#        # give the listener in other process a bit to get started...
#        sleep 1 ;
#        # then show that it did...
#        print \`(ps -ef ; netstat -an) | grep \$port | grep -v grep\`;
#        print "\\n\\n";
#      } else {
#        chomp(\$nc = \`which nc\`);
#        if (-x "\$nc" ) {
#          chomp(\$iptables = \`which iptables 2>/dev/null\`);
#          if (-x "\$iptables" ) {
#            print "
#Inserting firewall rules:
#iptables -A INPUT --proto tcp --destination-port 9999 -s 10.0.0.0/8 -j ACCEPT
#iptables -A INPUT --proto tcp --destination-port 9999 -s 192.168.0.0/16 -j ACCEPT
#iptables -A INPUT --proto tcp --destination-port 9999 -j REJECT
#";
#            \`\$iptables -A INPUT --proto tcp --destination-port 9999 -s 10.0.0.0/8 -j ACCEPT\`;
#            \`\$iptables -A INPUT --proto tcp --destination-port 9999 -s 192.168.0.0/16 -j ACCEPT\`;
#            \`\$iptables -A INPUT --proto tcp --destination-port 9999 -j REJECT\`;
#            \`\$iptables -L\`;
#          } else {
#            print "\$COLOR_WARNING
#\\aWARNING: No iptables in path, so the whole world can
#see your op data on port 9999...
#\$COLOR_NORMAL";
#          }
#          print "
#Starting listener in background with command:
#
#egrep -v \"^OP DETAILS|^REM|^\#|^-- -------\" \$topdate/$DOWN/opnotes.txt | \$nc -l -p \$port
#
#The output from this will confirm it is running:
#
#(ps -ef ; netstat -an) | grep \$port | grep -v grep
#";
#          exec "egrep -v \"^OP DETAILS|^REM|^\#|^-- -------\" \$topdate/$DOWN/opnotes.txt | \$nc -l -p \$port";
#        } else {
#          die ("ERROR: No \"nc\" in path.");
#        }
#        exit;
#      }
#    } else {
#      \$listener = 0;
#    }
#  } # end while Y/N/none
#  \$tmp = 0;
#  print "\\nPausing.";
#  while (\$tmp++ < 4) {
#    print ".";
#    sleep 1;
#  }
#}

### Workaround--we are resetting our FW timer to near zero.
if (\$fwcmdresetatend) {
  # TODO?: Maybe remove later
  printboth("Resetting timer on gateway FW to 1m and clearing rules with:    \$fwcmdresetatendnopasswd\n\n".
    "This can take a minute...\n\n".
    "");
  system(\$fwcmdresetatend);
} else {
  ### Tear down our gateway's firewall
  printboth("\\n\\nTearing down your gateway's firewall with:\n\n".
    "  \$fwcmddown\n\n".
    "This can take a minute...\n\n".
    "");
  #system("\$fwcmddown 2>&1 | tee -a \$logfile");
  system("\$fwcmddown");
}

foreach \$interface ("${PUBLICETHER}","ppp") {
    chomp(my \$check = \`ifconfig | grep \$interface\`);
    my \$secondtime=0;
    while (\$check) {
        my \$ans     = &getinput("$check\\n\$interface interface is still active. Shut it down?","Y");
        last unless \$ans =~ /^y/i;
        if (\$secondtime++) {
            if (\$secondtime > 1) {
                # Third time through we give up
                printboth("\$COLOR_FAILURE\\aWARNING: CANNOT GET RID OF \$interface: \$check\\n\\n\$COLOR_NORMAL");
                printboth("Exiting anyway. Let someone know.\\n\\n");
                sleep 2;
                last;
            }
            # Second time through we play rough
            if (\$interface eq "ppp") {
                printboth("Running killall pppd wvdial stupisp\\n\\n");
                system("killall pppd wvdial stupisp 2>&1 | tee -a \$logfile");
            } else {
                printboth("Downing \$interface\\n\\n");
                system("ifconfig \$interface down 2>&1 | tee -a \$logfile");
            }
        } else {
            # First time through try gently
            if (\$interface eq "ppp") {
                printboth("Running phone stop\\n\\n");
                system("phone stop 2>&1 | tee -a \$logfile");
            } else {
                printboth("Downing \$interface\\n\\n");
                system("ifdown \$interface 2>&1 | tee -a \$logfile");
            }
        }
        sleep 1;
        chomp(\$check = \`ifconfig | grep \$interface\`);
        if (\$check) {
            sleep 2;
            chomp(\$check = \`ifconfig | grep \$interface\`);
        }
    }
}

#### Start sending data, ISP info, and notes back and forth
# Put iptables rules into place beforehand
\$opnotesport = 9999;
#printboth("\\nINSERTING IPTABLES RULES BEFORE EXCHANGING DATA BETWEEN BOXES!\\n");
#printboth("
#iptables -A INPUT --proto tcp --dport \$opnotesport -s 10.0.0.0/8 -j ACCEPT
#iptables -A INPUT --proto tcp --dport \$opnotesport -s 192.168.0.0/16 -j ACCEPT
#iptables -A INPUT --proto tcp --dport \$opnotesport -j REJECT
#");
#\`iptables -A INPUT --proto tcp --dport \$opnotesport -s 10.0.0.0/8 -j ACCEPT 2>&1 | tee -a \$logfile\`;
#\`iptables -A INPUT --proto tcp --dport \$opnotesport -s 192.168.0.0/16 -j ACCEPT 2>&1 | tee -a \$logfile\`;
#\`iptables -A INPUT --proto tcp --dport \$opnotesport -j REJECT 2>&1 | tee -a \$logfile\`;
#\`\iptables -L -n -v 2>&1 | tee -a \$logfile\`;

# Send the ISP info over to windows
#\$ncans = getinput("\\nDo you want to start a netcat listener on port \$ispinfoport 
#to dump the contents of:
#\$topdate/$DOWN/ispinfo.txt? ", "N");
#if (\$ncans =~ /^[yY]/) {
#        system("sendispinfo");
#}

\$ncans = "N";
\$ncans = "Y" if (keys %winhosts > 0);

printboth("Targets section in opnotes.txt so far (before combining with other station):\n\n".
    \$alltargets."\n\n");
if (keys %successfulwinhosts > 0) {
    \$ncans = "D"; # "D" for default, we don't even prompt
    my \$ans = ("We have successful windows hops, do you want to merge Windows and Unix opnotes (you should)?",
                "Y",);
    if (\$ans eq "Y") {
       \$ncans = "D";
      printboth("About to run 'getopnotes $PRIVATEIP', a listener that accepts opnotes from the Windows station.\n".
                "Run pitchInfo.pl on windows station now...");

    } else {
       \$ncans = "N";
    }
} else {
    # Get opnotes if necessary before validation
    printboth("\\nNOTE: The following step, if answered affirmatively, will backup
/current/down/opnotes.txt as /current/down/opnotes.bak, and then save the remote
data as /current/down/opnotes.txt.  If there is a target list in both sets of
notes, you will be asked to merge these into one list here.

YOU MUST PERFORM THIS STEP IF THERE WAS A WINDOWS PORTION OF THE OP!!!!\\n\\n");
    \$ncans = getinput("Do you want to set up a listener to grab Op Notes from the other box before Op Notes validation?",
                    \$ncans);
}
\$gotwindowsnotes = "";

while (\$ncans =~ /^[yYD]/) {
    preservefile("\$topdate/$DOWN/opnotes.txt.bak");
    # Getopnotes here will crush the opnotes.txt.bak file, above preserves previous if any
    preservefile("\$optmp/getopnotes.output");
    system("getopnotes $PRIVATEIP 2>&1 | tee \$optmp/getopnotes.output");
    my \$output=myreadfile("\$optmp/getopnotes.output");
    printboth("From getopnotes $PRIVATEIP:\n\n");
    printboth(\$output);
    (\$gotwindowsnotes) = \$output =~ /SRCIP=(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/ ;
    if (\$gotwindowsnotes and -s "\$topdate/$DOWN/opnotes.txt") {
        \$ncans = "D";
        last;
    } else {
        \$gotwindowsnotes = "NO_SRC_IP_IN_OUTPUT";
        my \$why = " (opnotes.txt is empty)" unless (-s "\$topdate/$DOWN/opnotes.txt" > 0);
        my \$ans2 = getinput(
                    "\$COLOR_FAIL\n\n".
                    "That seemed to fail\$why. You can maybe re-try pitchInfo.pl on the windows side.\n\n".
                    "Do you want to try again?","Y");
        next if (\$ans2 =~ /y/i);
        \$gotwindowsnotes = "";
        last;
    }
}

### ASSERT: If getopnotes ran, the opnotes.bak was the original unix one, and .txt
###         one is now the windows copy.

### Resolve IP address conflicts between notes and collected data ###
\$resolvedone = 0;
%projectnamefromnotes = ();
\$projectnamefromnotes = ""; # Global, will become what last line project is
my %unsuccessfulips = ();
my %successfulips = ();
my \$opnoteslinenum = 0;
my \$opnotespitchlinenum = 0;
RESOLVE: while (\$resolvedone == 0)
{
  # If there are target lists in both files, tell the operator to get rid of
  # the one in the Unix file and put the correct list in the Windows file
  while (1) {
    open(FIRSTNOTES, "< \$topdate/$DOWN/opnotes.txt");
    \$attarglist = 0;
    \$foundipfirst = 0;
    \$malformed = 0;
    \$pitchindexinnotes=-1;
    \$targtypeindexinnotes=-1;
    my \$extracomment = " in Unix notes";
    \$extracomment = " in Windows notes"
      if \$gotwindowsnotes;
    while (<FIRSTNOTES>) {
      \$opnoteslinenum++;
      # Anchor the right of the IP with whitespace--so if hostname ends
      # in a digit, we are ok
      \$attarglist = 1 if (/^Targets/i);
      next unless \$attarglist;
      \$foundipfirst = 1
          if (processline(\$_,\$extracomment,"opnotes.txt"));
      last if (/^Results/i); # end of target list
    }
    close(FIRSTNOTES);
    \$attarglist = 0;
    \$foundipsecond = 0;
    \$opnoteslinenum = 0;
    # This may fail if no .bak (meaning no windows portion of op)
    # that is fine.
    open(UNIXNOTES, "< \$topdate/$DOWN/opnotes.bak");
    while (<UNIXNOTES>) {
      \$opnoteslinenum++;
      # Anchor the right of the IP with whitespace--so if hostname ends
      # in a digit, we are ok
      \$attarglist = 1 if (/^Targets/i);
      next unless \$attarglist;
      \$foundipsecond = 1
          if (processline(\$_," in Unix notes","opnotes.bak"));
      last if (/^Results/i); # end of target list
    }
    close(UNIXNOTES);

    if ((! \$foundipsecond and !\$foundipfirst) or \$malformed) {
        printboth("\\n\\nMALFORMED or EMPTY OPNOTES target lines (noted in red above).\\n\\n".
          "\$COLOR_NORMAL".
          "This might be not enough fields, which should look something like this:\\n\\n".
          "> 10.1.1.1      hostname.domain.com    pitchimpair    unix     success [comments]\\n".
          "-> 10.1.1.2     hostname2.domain.com   PROJECTNAME    TYPE     STATUS  [comments]\\n".
          "--> 10.1.1.2    hostname3.domain.com   PROJECTNAME    TYPE     STATUS  [comments]\\n".
          ".....\\n\\n".
          "\\n\\n".
          "Note that all fields are delimited by any number of whitespaces (space or tab).\\n\\n".
          "Where TYPE can be any of: \\n".
          "           w    windows   win\\n".
          "           u    unix      nix\\n".  
          "           unk  unknown\\n".
          "           f    firewall  fw\\n".  
          "           r    router    rtr\\n\\n".
          "           c    canopy    can\\n\\n".
          "STATUS can be any of: \\n".
          "           s      suc    succ    success    successful\\n".
          "           u      unsuc  unsucc  unsuccess  successful\\n".
          "           not    not-attempted\\n".
          "           non    nonstandard  non-standard\\n\\n".
          "and COMMENTS can be anything, including whitespace, e.g.:  exp GS INST SS SC DD\\n\\n".
          "\\n\\n".
          "You must fix this before you can continue.\\n\\n");
        sleep 2;
        my \$countdown=3;
        printboth("Continuing in \$countdown...\n");
        while (\$countdown-- > 0) {
            sleep 1;
            printboth("              \$countdown...\\n");
        }
        fixboth(\$malformed);
        next;
    }
    last unless (\$foundipsecond and \$foundipfirst);
    printboth("STOP HERE AND READ THIS!!!!!!

It looks like you have a target list in both the Unix opnotes and Windows notes. 
Please put the correct target list into opnotes.txt and delete the target list 
from opnotes.bak, and then press Enter to continue. Any notes in the 
\"Results\" section of both files should be unaffected.\\n");

    fixboth();

  } # end while (1)
        copy("\$opdown/opnotes.txt","\$opdown/opnotes.txt.".timestamp(short));
        copy("\$opdown/opnotes.bak","\$opdown/opnotes.bak.".timestamp(short));

        if (\$foundipsecond and ! \$foundipfirst) {
            ### ASSERT: We now have two copies, the .bak one is the unix one now complete
            ###         and the .txt one is the windows one but WITHOUT anything in its
            ###         target section.
            ###         We swap the two here, so .txt is now the good one either way.
                system("cp -vf \$opdown/opnotes.bak /tmp/a 2>&1 | tee -a \$logfile; cp -vf \$opdown/opnotes.txt \$opdown/opnotes.bak 2>&1 | tee -a \$logfile; cp -vf /tmp/a \$opdown/opnotes.txt 2>&1 | tee -a \$logfile; rm -vf /tmp/a 2>&1 | tee -a \$logfile");
        }
        # ASSERT: The opnotes.txt is the best at this point, .bak if there is the windows one.

        discoverips("\$topdate/$DOWN/opnotes.txt",
                    " in MERGED opnotes.txt","opnotes.txt");


        # Prompt here make sure it's ok, 
        # if it is not take fresh (unmodified by getopdata)
        # targets section from user and pray..
        \$ans = &getinput("\\n\\n".
                          "ORIGINAL TARGETS SECTION:\\n".
                          "---------------------------------\\n".
                          "\$originaltargets".
                          "---------------------------------\\n".
                          "MODIFIED TARGETS SECTION:\\n".
                          "---------------------------------\\n".
                          "\$modifiedtargets".
                          "---------------------------------\\n".
                          "You can revise the above modified targets section if you need to.\\n".
                          "If this looks at all wrong, answer No and you will be given a\\n".
                          "pop-up editor to fix just that section before it is put permanently\\n".
                          "into the final opnotes.txt.\\n".
                          "\\n\\n".
                          "Does the MODIFIED TARGETS SECTION look acceptable?".
                          "",
                          "Y");
        if (\$ans =~ /^n/i) {
          printboth("\\n\\nIn the pop-up vi window, modify the ENTIRE content\\n".
                "to how you want the final targets section to look. No further\\n".
                "automation will be attempted on this section and messing\\n".
                "it up can cause you lots of problems. So don't do that.\\n\\n");
          open(OPINFOOUT,"> \$topdate/.tmptargets");
          print OPINFOOUT \$modifiedtargets."\\n";
          close(OPINFOOUT);
          system("xterm -geometry 135x56-0-0 -title \"OP NOTES - FIX TARGETS SECTION\" -e \"\$editor \$topdate/.tmptargets\"");
          open(OPINFOIN,"\$topdate/.tmptargets");
          \$modifiedtargets = "";
          while (<OPINFOIN>) {
            \$modifiedtargets .= \$_ ;
          }
        }
        printboth("\\n\\nUsing new targets section to write final opnotes.txt:\\n".
            "---------------------------------\\n".
            "\$modifiedtargets\\n".
            "---------------------------------\\n");

        # Replace targets section in opnotes.txt with the \$modifiedtargets.
        # Save any previous .premods from old runs if any
        copy("\$opdown/opnotes.txt","\$opdown/opnotes.txt.".timestamp(short));
        copy("\$opdown/opnotes.bak","\$opdown/opnotes.bak.".timestamp(short));
        preservefile("\$topdate/$DOWN/opnotes.premod");
        rename("\$topdate/$DOWN/opnotes.txt",
               "\$topdate/$DOWN/opnotes.premod")
          or die "Cannot rename opnotes.txt to opnotes.premod, very bad\n";
        open(OPINFOIN, "< \$topdate/$DOWN/opnotes.premod");
        open(OPINFOOUT, "> \$topdate/$DOWN/opnotes.txt");
        my \$targsdone = 0;
        while (<OPINFOIN>) {
          print OPINFOOUT;
          if (/^Targets/i) {
            print OPINFOOUT \$modifiedtargets;
            last;
          }
        }
        while (<OPINFOIN>) {
          next unless (/^results/i or \$targsdone);
          \$targsdone++;
          print OPINFOOUT;
        }
        close(OPINFOIN);
        close(OPINFOOUT);

        printboth(gmtime()." Modified targets section put in final opnotes.txt\\n");

        discoverips("\$topdate/$DOWN/opnotes.txt");

        # For any addresses not in both places, figure out what the deal is
        unless (keys(%unknownIPdirs) == 0 and keys(%unknownIPnotes) == 0) {
                printboth("\\nTHERE ARE UNRESOLVED IP ADDRESSES BETWEEN OP DETAILS AND DOWNLOADED DATA:\\n\\n");
                printboth("\\n          ".scalar (keys %unknownIPdirs)." TARGET DIRECTORIES IN \$opdown DO NOT HAVE A CORRESPONDING TARGETS SECTION ENTRY\\n\\n")
                    if (%unknownIPdirs);
                printboth("\\n          ".scalar (keys %unknownIPnotes)." TARGET ENTRIES IN THE TARGETS SECTION FOR WHICH NO TARGET DATA HAS BEEN FOUND.\\n\\n")
                    if (%unknownIPnotes);
                foreach \$addr (keys %unknownIPnotes) {
                        printboth("\\nFound IP \"\$addr\" in OP DETAILS, but no directory for this.\\n");

                        # If unresolved addresses in the directory, print those out, maybe one
                        # corresponds to the other
                        unless (keys(%unknownIPdirs) == 0) {
                                printboth("\\nHere are IPs and the directories from \$opdown that contain them to which \"\$addr\" may correspond:\\n\\n");
                                my \$ipcount = 1;
                                my \$spaces = \$otheraddr;
                                my %whichips = ();
                                \$spaces =~ s,., ,g;
                                my \$morelines = join("\t\$spaces\t",split(/\n/,\$unknownIPdirs{\$otheraddr}));
                                foreach \$otheraddr (sort keys %unknownIPdirs) {
                                        printboth(" (\$ipcount)\t\$otheraddr\t\$morelines\\n");
                                        \$whichips{\$ipcount++} = \$otheraddr;
                                }
                                \$ipcount--;
                                printboth("\\n\\nThis could also be a Windows IP, non-NOPEN IP, unsuccessful IP, etc.  In this case, enter \"NONE\".\\n\\n");
                                \$ans = getinput("Enter corresponding IP from the list of \$ipcount IPs shown above, or \"NONE\" if none: ");
                                chomp \$ans;
                                if (\$ans =~ m,^\d+$,) {
                                    \$ans = \$whichips{int(\$ans)}
                                      if (defined  \$whichips{int(\$ans)});
                                }

                                # If none, remove it from the unaccounted for list
                                if (\$ans =~ /none/i) {
                                        delete(\$unknownIPnotes{\$addr});
                                        \$nofilename{\$addr}++;
                                        next;
                                }

                                # If one IP in the notes is the same box as another IP in the directory,
                                # note this in the notes with an "ALIAS" tag
                                if (exists(\$unknownIPdirs{\$ans})) {
                                        preservefile("\$topdate/$DOWN/opnotes.txt.alias");
                                        open(OPNOTESBEFORE, "< \$topdate/$DOWN/opnotes.txt");
                                        open(OPNOTESAFTER, "> \$topdate/$DOWN/opnotes.txt.alias");
                                        while (<OPNOTESBEFORE>) {
                                                if (/^Results/i) {  #  $addr in opnotes, $ans from $opdown
                                                        print OPNOTESAFTER "ALIAS: \$addr = \$ans\\n\\n";
                                                        \$aliasedip{\$addr} = \$ans;
                                                } 
                                                print OPNOTESAFTER unless /^ALIAS: \$addr = \$ans/;
                                        }
                                        close(OPNOTESBEFORE);
                                        close(OPNOTESAFTER);
                                        system("mv -f \$topdate/$DOWN/opnotes.txt.alias \$topdate/$DOWN/opnotes.txt");
                                        delete(\$unknownIPnotes{\$addr});
                                        delete(\$unknownIPdirs{\$ans});
                                }
                                else {
                                        # Indicated didn't match up with a known IP, prompt to make sure that
                                        # this is correct
                                        printboth("CANNOT FIX THIS AUTOMATICALLY.  YOU MUST FIX THE OP DETAILS MANUALLY.\\n");
                                        printboth("WHEN OP DETAILS FIXED, PLEASE HIT ENTER IN THIS WINDOW\\n\\n");
        copy("\$opdown/opnotes.txt","\$opdown/opnotes.txt.".timestamp(short));
        copy("\$opdown/opnotes.bak","\$opdown/opnotes.bak.".timestamp(short));
                                        system("xterm -title \"OP NOTES - opnotes.txt\" -e \"\$editor \$topdate/$DOWN/opnotes.txt\" &");

                                        while (1) {
                                                last unless \`ps -ef | grep "vim.*opnotes" | grep -v grep\`;
                                                sleep(2);
                                        }

                                        \$ans = getinput("Press Enter to continue.");
                                        next RESOLVE;
                                } # end else for unless (keys(%addrdirs) == 0)
                        } # end unless (keys(%unknownIPdirs) == 0 and keys(%unknownIPnotes) == 0)
                        else {
                                # Prompt to make sure that an IP in the notes that has no data (and that
                                # isn't saved under another IP address) is a valid state to be in
                                printboth("IP \$addr EXISTS IN NOTES, BUT THERE IS NO CORRESPONDING DIRECTORY FOR IT IN \"\$opdown\"\\n");
                                printboth("This could be because target was unattempted, unsuccessful, \\n");
                                printboth("a non-Unix target, etc.\\n\\n");
                                \$ans = getinput("Is this correct? (Y/N):", "n");
                                if (\$ans =~ /^[yY]/) {
                                        delete(\$unknownIPnotes{\$addr});
                                        \$nofilename{\$addr}++;
                                        next;
                                }
                                # If we are here, need to go fix the notes manually and then try again
                                # later...
                                printboth("CANNOT FIX THIS AUTOMATICALLY.  YOU MUST FIX THE OP DETAILS MANUALLY.\\n");
                                printboth("WHEN OP DETAILS FIXED, PLEASE HIT ENTER IN THIS WINDOW\\n\\n");
        copy("\$opdown/opnotes.txt","\$opdown/opnotes.txt.".timestamp(short));
        copy("\$opdown/opnotes.bak","\$opdown/opnotes.bak.".timestamp(short));
                                system("xterm -title \"OP NOTES - opnotes.txt\" -e \"\$editor \$topdate/$DOWN/opnotes.txt\" &");

                                while (1) {
                                        last unless \`ps -ef | grep "vim.*opnotes" | grep -v grep\`;
                                        sleep(2);
                                }

                                \$ans = getinput("Press Enter to continue.");
                                next RESOLVE;
                         } # end else for unless (keys(%unknownIPdirs) == 0 and keys(%unknownIPnotes) == 0)
                } # end foreach \$addr (keys %unknownIPnotes)

                # Now check to resolve any outstanding IP's in the directory structure
                unless (keys(%unknownIPdirs) == 0) {
                        my \$count = keys %unknownIPdirs;
                        my \$iplist = "";
                        foreach my \$addr (keys %unknownIPdirs) {
                            \$iplist .= sprintf(" IP = %15s  DATA FILE/DIR IN \$opdown:  \$unknownIPdirs{\$addr}",\$addr);
                        }
                        printboth("============================================================================\n");
                        printboth("\$iplist\n");
                        printboth("============================================================================\n");
                        printboth("THERE ARE \$count IP ADDRESSES NOT IN THE OP DETAILS TARGETS SECTION FROM WHICH\\n");
                        printboth("DATA HAS BEEN COLLECTED. ABOVE ARE THOSE IPs ALONG WITH THE DATA IN \$opdown\\n");
                        printboth("FROM EACH IP.\\n\\n");
                        printboth("YOU MUST EITHER ADD THESE HOSTS TO YOUR TARGETS SECTION OR CORRECT ANY TYPOS OR\\n");
                        printboth("OTHER MISTAKES THAT LED TO THIS DISCONNECT BEFORE PROCEEDING. WHEN YOU HAVE FINISHED\n");
                        printboth("EDITING YOUR NOTES FILE AND/OR MOVING/RENAMING FILES/DIRS, HIT ENTER TO CONTINUE!!!\\n\\n");

        copy("\$opdown/opnotes.txt","\$opdown/opnotes.txt.".timestamp(short));
        copy("\$opdown/opnotes.bak","\$opdown/opnotes.bak.".timestamp(short));
                        system("xterm -title \"OP NOTES - opnotes.txt\" -e \"\$editor \$topdate/$DOWN/opnotes.txt\" &");

                        while (1) {
                                last unless \`ps -ef | grep "vim.*opnotes" | grep -v grep\`;
                                sleep(2);
                        }

                        \$ans = getinput("Press Enter to continue.");
                        next RESOLVE;
                } # end unless (keys(%unknownIPdirs) == 0)
        } # end unless (keys(%unknownIPdirs) == 0 and keys(%unknownIPnotes) == 0)

        # We confirm \$gbl_opproject if it isn't showing up in targets yet
        unless (\$projectlist{lc \$gbl_opproject}) {
            my \$more = "";
            foreach (keys %gbl_externalIP) {
                \$more .= "    \$_\n";
            }
            \$more = "PUBLIC IPs USED:\n\$more"
                if \$more;
            if (\$gbl_modifiedtargets) {
                \$more .= "\n\nTargets thus far in Unix Opnotes:\n\$gbl_modifiedtargets\n\n";
            } elsif (\$gbl_targets) {
                \$more .= "\n\nTargets thus far in Unix Opnotes:\n\$gbl_targets\n\n";
            }
            \$gbl_opproject = "NOTHING" unless \$gbl_opproject;
            \$ans = &getinput(
                "Op synopsis thus far:\n\n".
                \$more.
                "Op Bandwidth: \$opmegs M\n\n".         
                "You initially defined \"\$gbl_opproject\" as the project for this op, but that is not one of the projects in your opnotes.\n".
                "Please correct any error in that project name here and/or in your opnotes.\n\n",
                "Project name: ".
                \$gbl_opproject);
            # Clean out garbage chars
            \$ans =~ s/[^a-zA-Z0-9_]//g;
            newhostvar("gbl_opproject",lc \$ans) unless (!\$ans);
            next RESOLVE;
        }

        # Make sure found at least one target in the target list
        unless (\$foundtargets) {
                printboth("DID NOT FIND A TARGET LIST IN OPNOTES.TXT!!!  PLEASE FIX THIS FOR OP");
                printboth("NOTES VALIDATION!!!!\\n\\n");
        copy("\$opdown/opnotes.txt","\$opdown/opnotes.txt.".timestamp(short));
        copy("\$opdown/opnotes.bak","\$opdown/opnotes.bak.".timestamp(short));
                system("xterm -title \"OP NOTES - opnotes.txt\" -e \"\$editor \$topdate/$DOWN/opnotes.txt\" &");

                while (1) {
                        last unless \`ps -ef | grep "vim.*opnotes" | grep -v grep\`;
                        sleep(2);
                }

                \$ans = getinput("Press Enter once there is a target list in opnotes.txt");
                next RESOLVE;
        }

        # Check if we have resolved all the issues
        \$resolvedone = 1 if (keys(%unknownIPdirs) == 0 and keys(%unknownIPnotes) == 0);

} # end RESOLVE:

# Parse op notes, figure out projects names and order of hosts in the tarball
# file name
open(OPNOTESIN, "< \$topdate/$DOWN/opnotes.txt");
\$intarglist = 0;
@targlist =  ();
while (<OPNOTESIN>) {
  last if (/^Results/i);
  next if (/^ALIAS:/i);
  if (my \$ip = processline(\$_,"quiet")) {
    \$indented = index(\$_, \$ip);
    push(@targlist, \$ip);
    push(@targlist, \$indented);
    dbg("asdf1234 - pushed ip=\$ip=  and indented=\$indented= onto targlist, now is targlist=(@targlist)");
  }
}
close(OPNOTESIN);

\$projectname = "";
\$projectname = \$projectnamelower ;
\$projectname = \$projectnamefromnotes
   if (\$projectnamefromnotes and !\$projectname );

# This call to autoutils will re-read opnotes.txt just saved to set \$gbl_* variables.
do "\$topdate/etc/autoutils" ;

# Last resort: If above does not yet set it but the \$gbl_* variables have it, use that.
\$projectname = \$gbl_projectlist[\$#gbl_projectlist]
  if (length  \$gbl_projectlist[\$#gbl_projectlist] and !\$projectname) ;

my \$atleast = 1;
while (\$atleast-- or ! \$projectname) {
  \$projectname = &getinput("\\nEnter Project Name for this Op: ",
                            \$projectname);
}

# Default first hop always to pitch unless \$nsrat in use
# APR2013: NO LONGER: \$projectmap{\$targlist[0]} = "pitchimpair" unless \$nsrat;

# Build rest of IP/project mappings
for (\$pitchindex = 0; \$pitchindex < scalar @targlist; \$pitchindex += 2) {
  if (\$projectnamefromnotes{\$targlist[\$pitchindex]}) {
    \$projectmap{\$targlist[\$pitchindex]} = \$projectnamefromnotes{\$targlist[\$pitchindex]};
  } else {
    \$projectmap{\$targlist[\$pitchindex]} = \$projectnamelower;
  }
}
\$lsoutput = \`ls -1 \$topdate/bin/varkeys/pitchimpair\`;
@lslines = split(/\\n/, \$lsoutput);
foreach \$ipaddr (keys %projectmap) {
        foreach \$lsline (@lslines) {
                if (\$lsline =~ /\$ipaddr\$/) {
                        \$projectmap{\$ipaddr} = "pitchimpair";
                        last;
                }
        }
}

my %pitchhostip = ();
my \$pitchhostip = "";
# Get confirmation for project names for each IP
printboth("\\nCONFIRMING PROJECT NAMES FOR EACH IP ADDRESS, FOR USE IN TARBALL NAME:\\n\\n");
foreach \$ipaddr (keys %projectmap) {
  unless (exists(\$nofilename{\$ipaddr})) {
    \$projectmap{\$ipaddr} = getinput("Enter Project Name for IP \$ipaddr:", \$projectmap{\$ipaddr});
    if (\$aliasedip{\$ipaddr}) {
      \$projectmap{\$aliasedip{\$ipaddr}}=\$projectmap{\$ipaddr};
    }
    if (lc \$projectmap{\$ipaddr} eq "pitchimpair") {
        if (\`find \$topdate/${DOWN}/*.\$ipaddr -maxdepth 0 -type d 2>/dev/null | head -1\`
              =~ m,/down/(\S*),) {
            \$pitchhostip{\$ipaddr} = \$1 ;
            \$pitchhostip = \$1 unless \$pitchhostip;
        }
    }
  }
}

# Rename all the unixdump.* files so the PITCH HOST.IP 
# and \$projectnamelower is in there for easy finding later.
# Also output the list of them and put them in opnotes.txt.
printboth("Renaming unixdump pcap files for your op:\\n");
foreach my \$dumpfile (split(/\\n/,\`find $TOP/pcaps/unixdump.*\`)) {
  my \$newname = \$dumpfile;
  \$newname =~ s/unixdump\\./\${pitchhostip}_/;
  if (\$newname =~ /\\.info/) {
    \$newname =~ s/\\.info/.\$projectnamelower.info/;
  } else {
    \$newname .= ".\$projectnamelower.pcap";
  }
  my \$dumpbase = basename \$dumpfile;
  printboth(" \$dumpbase -> \$newname\\n");
  rename(\$dumpfile,\$newname);
}
printboth( my \$pcapfilelist = 
   "PCAP Captures of your entire op can be found\\n".
   "here later if need be:\\n--------------------------------------------\\n".
   "ls -alrt $TOP/pcaps/\$pitchhostip*\$projectnamelower.pcap | sort +4n\\n".
   \`ls -alrt $TOP/pcaps/\$pitchhostip*\$projectnamelower.pcap | sort +4n\`.
   "\\n\\n");


# We put the last few lines of bwmonitor.txt into the opnotes.
my \$bwmonitorfile = "\$topdate/$DOWN/bwmonitor.txt" ;
my \$bwtest = \`ps -efwwwww |grep -v \$\$ | grep Bandwidth\`;
my (\$xtermpid) = \$bwtest =~ /root\s+(\d+)\s/;
# We are done, so stop the bwmonitor if it is still running.
if (\$xtermpid > 1) {
    kill TERM,\$xtermpid;
}
my \$bwmontail = \`tail -4 \$bwmonitorfile\` ;
if (\$bwmontail and open(OPNOTESOUT,">> \$topdate/$DOWN/opnotes.txt")) {
  print OPNOTESOUT "###################\\n".
                   "SCRUBHANDS v${SCRUBVER} (suite v${SUITEVER} run in \$suite/\$ethprivaddr) command line:\\n:\\n".
                   "${CALLEDAS}\\n".
                   "###################\\n";
  printboth(       "###################\\n".
                   "SCRUBHANDS v${SCRUBVER} (suite v${SUITEVER} run in \$suite/\$ethprivaddr) command line:\\n:\\n".
                   "${CALLEDAS}\\n".
                   "###################\\n");

  print OPNOTESOUT "Final lines of bwmonitor.txt:\\n" ;
  printboth("Final lines of bwmonitor.txt:\\n");
  print OPNOTESOUT \$bwmontail."\n" ;
  printboth(\$bwmontail."\n");
}
close(OPNOTESOUT);



# We want every PITCHIMPAIR to have its own copy of bwmonitor.txt. Bit of a waste
# of bytes but we hardly ever have more than one PITCH.
my \$bwmoncopied = 0;
if (-f \$bwmonitorfile and
    -s _ and keys %pitchhostip > 0) {
  # bwmonitor.txt: we are close to done now, so rename it with PITCHIMPAIR ip.hostname
  printboth("\\n\\nCopying bwmonitor.txt file once per PITCHIMPAIR:\\n");
  foreach my \$pitchhostip (keys %pitchhostip) {
    print \`cp -p \$mvv \$bwmonitorfile \$bwmonitorfile.\$pitchhostip 2>&1 | tee -a \$logfile\`;
    \$bwmoncopied++;
    if (open(PCAPSOUT,">>\$topdate/$DOWN/pcaps_list_from_op.\$pitchhostip")) {
      print PCAPSOUT \$pcapfilelist ;
    }
    close(PCAPSOUT);
  }
}


# WTF WAS THIS FOR? rename(\$bwmonitorfile,"\$topdate/bwmonitor.txt");
# OK: Needs to be in /current so put it there with copy, unlink it IF we 
# duped it above to at least one pitchip
copy(\$bwmonitorfile,"\$topdate/bwmonitor.txt");

# Build the "redirect" lines
# The host that redirected to it is the previous host in the list whose 
# indentation is less than the current hosts' indentation
\$redirectcount = 1;
open(REDIRECTINFOOUT, "> \$topdate/$DOWN/redirectinfo.txt");
for (\$redirindex = 0; \$redirindex <= scalar @targlist; \$redirindex += 2) {
  for (\$redirindexinner = \$redirindex - 2; \$redirindexinner >= 0; \$redirindexinner -= 2) {
    if (\$targlist[\$redirindexinner + 1] < \$targlist[\$redirindex + 1]) {
      if (\$projectmap{\$targlist[\$redirindexinner]} eq "pitchimpair") {
        print REDIRECTINFOOUT "Redirecting Method \$redirectcount:\tPITCHIMPAIR\\n";
      } else {
        print REDIRECTINFOOUT "Redirecting Method \$redirectcount:\tINCISION\\n";
      }
      print REDIRECTINFOOUT "Redirect Host \$redirectcount:\t\$targlist[\$redirindexinner]\\n";
      print REDIRECTINFOOUT "Redirect Target \$redirectcount:\t\$targlist[\$redirindex]\\n";
      \$redirectcount++;
      last;
    }
  }
}
close(REDIRECTINFOOUT);

        copy("\$opdown/opnotes.txt","\$opdown/opnotes.txt.".timestamp(short));
        copy("\$opdown/opnotes.bak","\$opdown/opnotes.bak.".timestamp(short));
# Create the "final" opnotes file with ispinfo, redirectinfo, and the notes
system("cd \$topdate/$DOWN; cat ispinfo.txt redirectinfo.txt opnotes.txt opnotes.bak 2>/dev/null > opnotes.txt.new; mv -f opnotes.txt.new opnotes.txt; rm -f opnotes.bak");
sleep 1;

        copy("\$opdown/opnotes.txt","\$opdown/opnotes.txt.".timestamp(short));
        copy("\$opdown/opnotes.bak","\$opdown/opnotes.bak.".timestamp(short));

# Send the notes back to the Windows side if need be
\$winnotesdefault = "N";
if (\$gotwindowsnotes) {
    \$winnotesdefault = "Y";
}

\$ncans = getinput("Do you want to push all op data, including the validated contents of opnotes.txt to the Windows box?" , \$winnotesdefault)
    unless (\$ncans eq "D");
my \$opnotesip = \$gotwindowsnotes;
my \$sharetarball = 0;
if (\$ncans =~ /^[yYD]/) {
    while (1) {
        \$gotwinbox = 1;
        \$sharetarball = 1;
        \$opnotesip = ""
            unless \$opnotesip =~ /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\$/ ;
        printboth("\n\nPushing validated opnotes.txt to the Windows box via sendopnotes...");
        copy("\$opdown/opnotes.txt","\$opdown/opnotes.txt.".timestamp(short));
        copy("\$opdown/opnotes.bak","\$opdown/opnotes.bak.".timestamp(short));
        preservefile("\$optmp/sendopnotes.output");
        system("OPNOTESIP=\$opnotesip sendopnotes 2>&1 | tee -a \$logfile | tee \$optmp/sendopnotes.output");
        my \$result = myreadfile("\$optmp/sendopnotes.output");

        printboth(\$result);
        if (\$result =~ /Sent (\d+)/i) {
            printboth("Sent opnotes.txt to \$opnotesip ($1 bytes)");
        } else {
            my \$ans2 = getinput(
                    "\$COLOR_FAIL\n\n".
                    "That seemed to fail. You'll have to transfer the complete opnotes.txt to the windows box manually.\n\n".
                    "Hit Enter to continue.");
        }
        last;
    }
} else {
    \$gotwinbox = 0;
}

# Build the default tarball file name, still can be overridden
%alreadybuilt = ();
\$tarballfilename = "";
for (\$tempindex = 0; \$tempindex < scalar @targlist; \$tempindex += 2) {
    dbg("asdf1234 - IP: \$targlist[\$tempindex]");
    dbg("asdf1234 - Indent: \$targlist[\$tempindex+1]");
}
buildfilename(@targlist);
dbg("asdf1234 - Final tarball name: =\$tarballfilename=");
\$tarballfilename =~ s/.tar.bz2/_\$gbl_opuser.tar.bz2/;
\$tarballfilename = "\${gbl_opstartdate}_\$tarballfilename";

# Default tarball filename might be too long
\$maxtarballnamelen = 200;
if (length(\$tarballfilename) > \$maxtarballnamelen) {
        printboth("\\nDEFAULT GENERATED TARBALL NAME TOO LONG!!!\\n");
        sleep 1;
        printboth("\\nDEFAULT GENERATED TARBALL NAME TOO LONG!!!\\n");
        sleep 1;
        printboth("\\nDEFAULT GENERATED TARBALL NAME TOO LONG!!!\\n");
        printboth("NAME WAS: \$tarballfilename\\n");
        \$tarballfilename = "";
}


# Notice about UNSUCCESSFUL targets showing in filename now
printboth("\\n\\n\\n\\nNOTE: UNSUCCESSFUL UNIX hops are now put into the tarball\\n".
                  "      filename. This new behavior is correct.\\n\\n");

printboth("\\nCreating tarball of \$topdate/$DOWN*\\n");
\$date = "\$datedir";
\$date =~ s/junk\.//;
\$target = "" ;
until (\$target) {
  \$target     = &getinput("          Target Name: ",\$tarballfilename);
}
\$tarball = "\$target.\$date.tar.bz2" ;


# Look elsewhere in \$opdir for stuff that maybe should be moved to down/
# before we pack it up.
#
my \$donemoving = 0;
while (! \$donemoving) {
  my @srcfiles = ();
  my %ipfiles = nondatafiles(0,\@srcfiles,"\$topdate");

  if (%ipfiles) {
    foreach my \$ip (sort keys %ipfiles) {
      printboth("\\n\$COLOR_NOTE\\n".
        "\$ip\\n===============\\n".\$COLOR_NORMAL.
        \$ipfiles{\$ip}.\$COLOR_NOTE .
        "\\n");
    }
    my \$count = scalar keys %ipfiles;
    \$ans = getinput(
        "getopdata found the above\$COLOR_FAILURE \$count\$COLOR_NORMAL files that contain what may be an IP address.\\n".
        "You can clean/move that data now. Be sure any target data ends up in \$opdown,\\n".
        "non-target data can be moved to \$optmp\\n\\n".
        "You will be prompted once per above file about moving it to \$opdown unless\\n".
        "they (or their parent directory) are moved now.\\n\\n"
        );
  }
  \$donemoving++;# Not using this actually, leave in in case we want to...
  foreach my \$ip (keys %ipfiles) {
    dbg("POTENTIAL IP FILES FOR IP=\$ip:\\n".
        \$ipfiles{\$ip});
    my (\$ans,\$dot) = ();
    my \$morename = \$gbl_hostnamehash{\$ip};
    foreach my \$file (split("\n",\$ipfiles{\$ip})) {
      \$file =~ s,^\$COLOR_FAILURE,,;
      \$file =~ s,\$COLOR_NORMAL$,,;
      # In case they've shifted things and this is not there anymore
      next unless (-f \$file);
      my \$dirname = dirname(\$file);
      \$dirname =~ s,^\$topdate/*,,;
      next unless \$dirname;
      if (\$morename and \$dirname =~ /$morename/i) {
          \$morename = "";
      }
      my \$newdir = "\$topdate/$DOWN/\$more\$dirname";
      until (\$ans =~ /^\s*[yn]/i) {
        \$ans = &getinput
           ("\$more\\n\\n".
        "===============\\n\\n".
        "  \$file\\n\\n".
        "getopdata found the above file not in /\$topdate/$DOWN,\\n".
        "and you have the option of moving it now to:\\n\\n".
        "  \$newdir\\n\\n".
        "If left where it is, it WILL be wiped after your op and WILL NOT\\n".
        "be put in your op tarball.\\n\\n".
        "You may also answer NO here AFTER taking care of it in another window.\\n\\n".
        "Move it to the new location?","Y");
        \$dot = ".\\n\$COLOR_FAILURE   INVALID ANSWER\$COLOR_NORMAL";
      }
      if (\$ans =~ /^\s*y/i) {
        my \$filebase = basename(\$file);
        \`mkdir -vp "\$newdir" 2>/dev/null 2>&1 | tee -a \$logfile\`;
        rename(\$file,"\$newdir/\$filebase");
        printboth("\\nMOVED TO:\\n\\nls -alrt \$newdir\\n".\`ls -alrt \$newdir\`);
      }
    }
    printboth("\\n\\n");
  }
}

# This will contain our filename that is the operator list
my (\$firstthis,\$opdonebyfile) = ();


if (@opusers = (\$gbl_opuser)) {
    my \$showerr = "";
    while (1) {
        my \$ans = getinput("\${showerr}List any other operators\' numeric ids, space or comma delimited:","NONE");
        last unless (\$ans and \$ans ne "NONE");
        \$ans =~ s/^\s*//;
        \$ans =~ s/\s+/,/g;
        unless (\$ans and \$ans =~ /^\d+(,\d+)*\$/ and \$ans > 0) {
            \$showerr = "\n\$COLOR_FAILURE\nINVALID RESPONSE, enter either nothing or (comma or space delimited) integers.\n\$COLOR_NORMAL\n";
            next;
        }
        push(@opusers,split(/[\s,]+/,\$ans));
        last;
    }
dbg("Got opusers=(@opusers)");
}

# We have at least one ID or would not be in here, so
# we make sure every id is there with "_" on each side.
\$operlist = "_".join("_",@opusers)."_";
my \$defaultans = "N";
\$defaultans = "Y" if \$nonstandard;
my \$nonstdans = getinput("\n\nWas this a nonstandard op?",\$defaultans);
print "\\a\n";sleep 1;
print "\n\n\$COLOR_FAILURE\n\\a".
    "NOTE: If you answer YES to this next question, YOU are\n".
    "      responsible for\$COLOR_NOTE MANUAL\$COLOR_FAILURE post processing.\n\n".\$COLOR_NORMAL;
print "\\a\n";sleep 1;
my \$ans2 = getinput(
    "Will special post-processing be required?","N");
my \$baddog = "";
while (1) {
    my \$default = "ENTER NONE IF THERE ARE NONE";
    my \$more = "";
    if (\$gbl_callbackresets) {
        \$default = "ENTER DONE IF THERE ARE NO MORE";
        \$more = " more";
    }
    my \$ans4 = uc getinput(
        "\$COLOR_FAILURE\$baddog\\nAny\$more callbacks need reset???????\$COLOR_NORMAL\\n".
        "\\n\\nValid answers here include these (or any space delimited mix thereof):\\n".
        "     PROJECT##           (name and # of OLY/UR)\\n".
        "     project##           (same, case does not matter)\\n".
        "     ######              (six+ digit Val ID)\\n".
        "     ###                 (less than six digits, time in hours to reset them to, defaults to policy.\\n\\n\\n".
        "\\n\\nEnter any\$more hosts that need callbacks reset:",
        \$default);
    last if (\$ans4 =~ /^[DN]ONE\$/);
    foreach my \$ans3 (split(/\s+/,\$ans4)) {
        if (\$ans3 =~ /^\d{1,5}\$/ and \$ans3 > 0) {
            newhostvar("gbl_callbackinterval",\$ans3);
            \$baddog = "";
        } elsif (\$ans3 !~ /^[A-Z_]*\d+\$/ and
                 (\$ans3 !~ /^\d{5}\d+\$/)) {
            \$baddog = "\\n\\nINVALID ANSWER!!\\n\\n";
        } else {
            \$gbl_callbackresets .= "," if \$gbl_callbackresets ;
            \$gbl_callbackresets .= \$ans3;
            newhostvar("gbl_callbackresets",\$gbl_callbackresets);
            \$baddog = "";
        }
    }
}


# Handling checkins
my %yesnotech =
    ("t",2,
     "n",0,
     "y",1);

my (%projecthash,%targetlines,%statushash,%typehash) = ();
# CHANGE THIS 0 to 1 to turn on checkins
my \$docheckins = ("$DOCHECKINS" or length \$ENV{"DOCHECKINS"}> 0) ? 1 : 0;
DOCHECKINS:
while (\$docheckins) {
    my \$opnotesage = -M "\$opdown/opnotes.txt";
    my \$opnotesagenew = -M "\$opdown/opnotes.txt";
    newhostvar("gbl_checkallin",1);
    my \$unsuccessfulpitch = "";
    # Build \$infralist from latest notes, maybe just changed
    my (\$pitchcount,\$publiccount) = (0,0);
    (\$project,\$targets,@projectlist) =
        opnotesprojects(
                        \\%projecthash,
                        undef,#\\%alias
                        undef,#\\%depth
                        undef,#\\%hostname
                        \\%statushash,
                        undef,#\\%typehash,
                        undef,#\\%commentshash,
                        \\%targetlines,
                        );
    my \$content = "";
    foreach my \$key (keys %targetlines) {
        \$content .= "targetlines{\$key}=$targetlines{\$key}=\n";
    }
    dbg("in DOCHECKINS loops, targetlines has now has ".scalar (keys %targetlines)." entries:\n".
        \$content);

    my \$infralist = "PITCHIMPAIRS\n============\n";
    foreach my \$ip (keys %targetlines) {
        next unless (lc \$projecthash{\$ip} eq "pitchimpair");
	\$pitchcount++;
        if (\$statushash{\$ip} !~ /^s/i) {
	    \$unsuccessfulpitch .= \$targetlines{\$ip}."\n";
	}
	\$infralist .= \$targetlines{\$ip}."\n";
    }

    if (\$unsuccessfulpitch) {
	getinput("\n\n".
		 "You have one or more PITCHIMPAIR redirectors not labeled successful.   To use autocheckin, only\n".
		 "successful pitches can be checked in.  Take a moment now and check in (or put in the tech check\n".
		 "queue), any pitches that were not successful.\n".
		 \$COLOR_NOTE.
		 \$unsuccessfulpitch.
		 \$COLOR_NORMAL."\n\n".
                 "Hit return to continue...".
		"");
    }
    \$opnotesagenew = -M "\$opdown/opnotes.txt";
    unless (\$opnotesage == \$opnotesagenew) {
	getinput("\n\n".
		\$COLOR_FAILURE.
		"You MODIFIED your opnotes.txt file. Let's back up a bit and re-do some of these prompts.\n\n".
		\$COLOR_NORMAL.
                 "Hit return to continue...".
		"");
	next DOCHECKINS;
    }

    \$infralist .= "\n";
    \$infralist .= "\n\nPUBLIC IPS\n==========\n";
    my \$current_externalIP = \$gbl_externalIP{"current"};
    my %publicipdone = ();
    foreach my \$str (keys %gbl_externalIP) {
        my \$ip = \$gbl_externalIP{\$str};
	next unless \$publicipdone{\$ip}++;
	\$publiccount++;
        \$infralist .= sprintf("%17s %s\n",\$ip,\$str);
    }
    if (\$publiccount > 1) {
        getinput(\$COLOR_FAILURE."\n\n".
                 "WARNING: \n".
                 "         With multpile PUBLIC IPs, autocheckin may be problematic.\n\n".
                 "         You are responsible for confirming that your op is properly checked in.\n".
                 \$COLOR_NORMAL."\n\n".
                 "Hit return to continue\n".
                "");
    }

    printboth("\n\n".
		"You have \$pitchcount PITCHIMPAIR redirectors and \$publiccount public IPs used during this op.\n\n".
		\$COLOR_NOTE.
		\$infralist.
		\$COLOR_FAILURE.
		"NOTE:  To use\$COLOR_NOTE autocheckin\$COLOR_FAILURE, the INFRASTRUCTURE for this operation must\n".
		"       EXACTLY match what is shown here. If it does not,\n".
		"       you must check in everything associated with this op yourself, manually.\n\n".
                \$COLOR_NOTE.
		"You can take a moment now and adjust accordingly, either here or elsewhere, so that you can use autocheckin.\n\n".		
		"\n\nHit Return to continue...");
    my \$checkindefault = \$gbl_checkallin ? "Y" : "N" ;
    my \$otherdoes = "Does";
    \$otherdoes = "Other than any unsuccessful ones (which you need to take care of yourself), does\n"
      if \$unsuccessfulpitch;
    my \$checkinans = uc getinput(
        "\$otherdoes the list above now\$COLOR_FAILURE COMPLETELY\$COLOR_NORNAL match the list assigned elsewhere to OP ID\$COLOR_NORMAL \$gbl_opschedule?",\$checkindefault);
    if (\$checkinans =~ /^\s*y/i) {
	newhostvar("gbl_checkallin",1);
    } else {
        newhostvar("gbl_checkallin",0);
    }
    \$opnotesagenew = -M "\$opdown/opnotes.txt";
    unless (\$opnotesage == \$opnotesagenew) {
        getinput("\n\n".
                \$COLOR_FAILURE.
                "You MODIFIED your opnotes.txt file. Let's back up a bit and re-do some of these prompts.\n\n".
                \$COLOR_NORMAL.
                "");
        next DOCHECKINS;
    }

    foreach my \$ip (keys %targetlines) {
        next unless (lc \$projecthash{\$ip} eq "pitchimpair");
        my (\$defaultans,\$more) = ("Y");
        if (\$statushash{\$ip} !~ /^s/i) {
            \$defaultans = "NO";
            \$more = "\$COLOR_FAILURE (this was \$statushash{\$ip})\$COLOR_NORMAL";
        }
        my \$errmore = "";
    
        while (\$docheckins) {
	    if (\$gbl_checkallin) {
		\$which = "y";
	    } else {
                \$ans1 = uc getinput
                    ("\n\n".
                    "Checking in your PITCH IP(s) used.\n\n".
                    \$pitchline{\$ip}."\n\n".
        #TODO: pitchline not populating right?
                    "You can answer <Y>es, <N>o, or <T>echcheck, and you may optionally add a\n".
                    "comment following your answer (on the same line, e.g. \"T did not trigger\").\n\n".
                    \$errmore.
                    "Did you want to check in PITCHIMPAIR \$ip\$more",\$defaultans);
                
                (\$which,undef,\$comment) = \$ans1 =~ /^\s*([ynt])(es|o|echcheck){0,1}\s*(.*)/i;
                unless (defined \$yesnotech{lc \$which}) {
                    \$errmore = \$COLOR_FAILURE."INVALID ANSWER: \$ans1\$COLOR_NORMAL\n\n";
                    next;
                }
	    }
            \$which = \$yesnotech{lc \$which};
            \$comment = " \$comment" if \$comment;
            newhostvar("gbl_pitchcheckin{\$ip}","\$which\$comment");
            last;
        }
    }

    my %didexternalIP = ();
    my \$current_externalIP = \$gbl_externalIP{"current"};
    foreach my \$str (keys %gbl_externalIP) {
        my \$ip = \$gbl_externalIP{\$str};
        next if \$didexternalIP{\$ip}++;
        my (\$defaultans,\$more,\$errmore) = ("Y");
        # Default to NO unless this is our current/active \$ip.
        unless (\$current_externalIP eq \$ip) {
            \$defaultans = "NO";
            \$more = "\$COLOR_FAILURE (which is NOT your current IP)\$COLOR_NORMAL";
        }

        while (\$docheckins){
            if (\$gbl_checkallin) {
                \$which = "y";
            } else {
                \$ans1 = uc getinput("\n\n".
                                    "Checking in your Public IP(s) used.\n\n".
                                    \$errmore.
                                    "Did you want to check in your public IP\$more \$ip?",
                                    \$defaultans);
                (\$which,undef,\$comment) = \$ans1 =~ /^\s*([ynt])(es|o|echcheck){0,1}\s*(.*)/i;
                unless (defined \$yesnotech{lc \$which}) {
                    \$errmore = \$COLOR_FAILURE."INVALID ANSWER: \$ans1\$COLOR_NORMAL\n\n";
                    next;
                } 
	    }
            \$which = \$yesnotech{lc \$which};
            unless (length "\$which" and \$which >= 0 and \$which < 2) { # YES OR NO ONLY NO TECH YET??
                \$errmore = \$COLOR_FAILURE."INVALID ANSWER: \$ans1\$COLOR_NORMAL\n\n";
                next;
            }
            \$comment = " \$comment" if (\$comment and ! \$comment =~ m,^\s+,);
            newhostvar("gbl_publiccheckin{\$ip}","\$which\$comment");
            last;
        }
    }
    \$opnotesagenew = -M "\$opdown/opnotes.txt";
    unless (\$opnotesage == \$opnotesagenew) {
        getinput("\n\n".
                \$COLOR_FAILURE.
                "You MODIFIED your opnotes.txt file. Let's back up a bit and re-do some of these prompts.\n\n".
                \$COLOR_NORMAL.
                "");
        next DOCHECKINS;
    }

    # Opnotes unchanged since last pass through, we are done
    last;
}

#CHECKINS DONE

\$opdonebyfile = "op.done.by\$operlist";
if (\$ans2 =~ /^y/i) {
  \$specialproc = 1;
#WHY? TODO why was this taken out does it not work?
#  mydo("autoproblem","-tTSELF",
#    "GETOPDATA SAYS: You answered \"\$ans2\" to the question \"Will special post-processing be required?\" on your \$gbl_project op.\n".
#    "TARGETS:\n\$gbl_targets");
} else {
    \$opdonebyfile .= "GTG_";
}
if (\$nonstdans =~ /^y/i) {
    \$nonstandard = 1;
    \$opdonebyfile .= "NST_";
    my \$opnotes = "\$topdate/$DOWN/opnotes.txt";
    #Non-Standard: True
    my @checkstd =
      split(/\n/,\`egrep -i "Non-Standard:.*True" \$opnotes\`);
    my \$gotone = 0;
    foreach (@checkstd) {
        \$gotone++ unless /^\s*\#/;
    }
    unless (\$gotone) {
        my \$ans = getinput(
            "\n\nYour opnotes.txt does not have the non-Standard: True line\n".
            "in it (uncommented). Do you want to add that line?","Y"
            );
        if (\$ans =~ /^y/i) {
            unlink("\$top/tmpnotes");
            rename(\$opnotes,"\$top/tmpnotes");
            open(OPOUT,">\$opnotes");
            open(OPIN,"\$top/tmpnotes");
            my \$didit=0;
            while (<OPIN>) {
                print OPOUT;
                if (!\$didit and /^\s*Results:/) {
                    print OPOUT "\\nNon-Standard: True\n";
                    \$didit++;
                }
            }
            print OPOUT "Non-Standard: True\n" unless \$didit;
            close(OPOUT);
            close(OPIN);
        }
    }
} else {
  \$nonstandard = 0;
}
\$opdonebyfile .= "${DATE}_";
my (\$sec,\$min,\$hour,\$mday,\$mon,\$year,\$wday,\$yday,\$isdst,\$monstr) =
    gmtime();
\$mon++;
\$year += 1900 unless \$year > 1900;
\$opdonebyfile .= sprintf("%4d%02d%02d-%02d%02d",\$year,\$mon,\$mday,\$hour,\$min);
\$opdonebyfile =~ s/_+/_/g;
\`rm -f \$topdate/$DOWN/op.done.by*\`;



# New method with pushing via copy-SPEED
# APR 2013: We no longer offer any choice, ops always go to slow,
# freshstep_tracker* always to fast.
my %valid = ();
my \$pushcmd = "copy-slow \$top/\$opdir/";
newhostvar("gbl_pushedvia","slow");


# Track op stop (do before tarball is created now, c. Mar 2010)
# This populates \$freshstep_contents so \$opdonebyfile gets latest content.
freshsteptracker("stop",\$projectnamelower);


# No longer putting this 
#    \`tail -4 \$bwmonitorfile 2>&1 >> \$topdate/$DOWN/\$opdonebyfile\`;
\$firstthis = " $DOWN/\$opdonebyfile";



# This is why down/opnotes.* is in tarball twice, we put it first
\$firstthis .= " $DOWN/opnotes.*";

unlink(\$bwmonitorfile) if \$bwmoncopied;


# move this, can cause trouble later
rename("/usr/local/bin/myenv","/usr/local/bin/myenv.".timestamp(short));


my @emptydirs = sort by_path_depth split(/\n/,\`find \$topdate/$DOWN -type d | sed -e 's/^/"/g'  -e 's/\\$/"/g'\`);
printboth("\n\nRemoving any empty directories in $DOWN:\n");
printboth(\`rmdir -v @emptydirs 2>/dev/null\`);
printboth(\`rmdir -v @emptydirs 2>/dev/null\`);

do \$global_varfile; # read in data about op just completed
my \$saveuserpw = \$gbl_oppasswd;
opuser("CLEAR"); # Ensures password is not put in tarball in any hostvars* files
my @didthisfiles = ();
if (opendir(GETOPDIR,"\$opdown")) {
  @didthisfiles = grep /^didthis/ , readdir(GETOPDIR);
  closedir(GETOPDIR);
}

my \$what = "other files";
if (@didthisfiles > 1) {
  \$what = "other files (@didthisfiles)";
}
printboth("\n\nDuplicating \$global_varfile and \$what for each Unix host seen.");
my %wipethese = ();
foreach my \$rhost (keys %gbl_nopenhosts) {
  foreach \$tfile (@didthisfiles,"ispinfo.txt","redirectinfo.txt") {
    my \$tfile2 = "\$opdown/\$tfile";
    if (-f \$tfile2) {
        #printboth("copying \$tfile2 \tto \$tfile2.\$rhost");
        copy("\$tfile2","\$tfile2.\$rhost")
            and \$wipethese{\$tfile2}++;
    }
  }
  if (-f \$global_varfile) {
    #printboth("copying \$global_varfile \tto \$global_varfile.\$rhost");
    copy(\$global_varfile,"\$global_varfile.\$rhost")
        and \$wipethese{"\$global_varfile"}++;
  }
}
unless (scalar keys %gbl_nopenhosts <= 0) {
#  foreach my \$thisfile (@didthisfiles,"ispinfo.txt","redirectinfo.txt") {
  foreach my \$thisfile (keys %wipethese) {
    # Delete originals now, we got dupes per host
    printboth("Removing \$thisfile");
    unlink(\$thisfile);
  }
}



printboth(\`ls -al \$global_varfile.* \$opdown/didthis.*\`);
printboth("Building \$topdate/\$tarball with:\\n\\n");

# We MOVE \$logfile now into $DOWN, it will be in tarball from now on
\$firstnopen_rhostname .= "." if \$firstnopen_rhostname;
rename(\$logfile,"$DOWN/\$gbl_firstnopen_rhostname".basename(\$logfile));
\$firstthis .= " $DOWN/\$gbl_firstnopen_rhostname".basename(\$logfile);


# MAYBE DO THIS HERE LIKE IN createtarball()? needs fork that dies and here we tail -f it
#    if (open(TARBALLIN,"\$tarcmd |")) {
#      \$| = 1;
#      while (<TARBALLIN>) {
#        print ;
#      }
#      close(TARBALLIN);
#    }
# Never mind, we do not want \$firstthis first anymore:
\$firstthis = "";
# Add 
printboth("tar cvjf \$tarball \$firstthis op.done.by* $DOWN*\\n\\n");
printboth(\`tar cvjf \$tarball \$firstthis op.done.by* $DOWN* ; ls -al \$tarball\`);
if (\$?) {
  printboth("DOH! Couldn't build tarball with this:


tar cvjf \$tarball \$firstthis op.done.by* $DOWN* 


Something seriously wrong there.....\\a

");

  # For now, preserve these...eventually get rid of them here as the one just
  # packed up had the tail end of the last log, and the new stuff from op just done.
  preservefile(\$logfile);
  sleep 2;
} else {
  #this way was too much too soon
  #@wipethese = split( /\\n/ , \`ls -a1 \$topdate | egrep "$TOOLS|$TEXTS|$UP|$DOC"\`);

  @wipethese = split(/ /, "$WIPETHESE");

  printboth("\\n\\n\\aFollowing files & directories will be deleted next time
$PROG is run:\\n");

  foreach (@wipethese) {
    printboth("\t\$_\\n");
#not done here, now at top of ${PROG}
#    \`rm -rf \$topdate/\$_\`;
  }

  if (-e "/tmp/zipstatus") {
    \$zipstatus = myreadfile("/tmp/zipstatus");
    unlink ("/tmp/zipstatus");
  }
  \$notdone = 1;
  \$size = -s "\$tarball" ;
  \$floppycount=0;
}
# Now we leave \$tarball in /current
#\`rm -f \$tarball\`;

printboth("\\n\\n\\n");

my \$opdir = \$datedir;

# No longer renaming topdate ever too confusing, no need with GEN3s anyway
#if ("\$topdate" =~ /-\$target\$/) {
#    printboth("\\nOp data directory REMAINS IN  \$topdate\\n");
#} else {
#    rename("\$topdate","\$topdate-\$target");
#    \$topdate = "\$topdate-\$target";
#    \$opdir = "\$datedir-\$target";
#    unlink("/current");
#    symlink("\$top/\$opdir","/current");
#    printboth("\\nOp data directory renamed to \$opdir\\n");
#    chdir("\$top/\$opdir");
#}

# by now this one is already in /usr/local/bin if it needs to be and it
# can mess up the next guy if it is an old one so bag it.
unlink("\$top/\$opdir/bin/scrubhands") ;

my \$terminate = 0;
while (!\$terminate) {
    if (\$sharetarball) {
        # Winbox will take care of the push, delete old files first
        \`rm -rf /share/down/NOTDONE* /share/down/op.done* /share/down/*bz2 /share/down/opnotes.txt ; touch /share/down/NOTDONE\`;
        my \$checksmb = \`service smb status\`;
        system("service smb restart 2>&1 | tee -a \$logfile") if \$checksmb =~ /smbd.*stopped/;
        copy("\$top/\$opdir/$DOWN/opnotes.txt","/share/down/opnotes.txt");
        copy("\$top/\$opdir/$DOWN/\$opdonebyfile","/share/down/");
        copy("\$tarball","/share/down/NOTDONE") ;
        # Winbox scripts should ignore it with NOTDONE, once done with copy,
        # this rename makes it end in bz2.
        \`chmod -R a+rwX /share/down/*\`;
        system("sync");
        sleep 3;
        system("sync");
        rename("/share/down/NOTDONE","/share/down/\$tarball") ;
        rename("\$tarball","/root/PUSHED/\$tarball.winpushed");
        \`chmod -R a+rwX /share/down/*\`;
        my \$tarballatime = -A "/share/down/\$tarball";
        my \$sleepcount = 0 ;
        printboth("\\n\\n\\n\\n\$COLOR_NOTE\\n\\n\\n");
        printboth("You can proceed now on the windows ops box.\\n\\n".
          "It can now see the tarball and opnotes.txt on the share:\\n\\n".
          \`ls -al /share/down/\$tarball /share/down/op*\`);
        sleep 2;
        while (1) {
            my \$still = "";
            printboth("\n".gmtime()." ...\${still}waiting on Windows ops box to access the tarball...")
              if (\$sleepcount == 0 or ! \$sleepcount % 15);
            \$still = "still ";
            sleep 1 ;
            \$sleepcount++;
            my \$newtime = -A "/share/down/\$tarball";
            last if \$newtime < \$tarballatime;
        }
        my \$countdown = 6;
        printboth("\\n\\nSomething just accessed \$tarball\\n".
         "presumably the Windows ops box...\\n\\n".
         "Giving it \$countdown seconds to finish the copy...\\n");
        while (\$countdown-- > 0) {
            sleep 1;
            printboth("   \$countdown...\\n");
        }
        print
           ("This system will scrub and reboot when you hit RETURN below.\\n\\n".
            "Or you can Ctrl-C here and run copy-[fast|slow|emerg] manually\\n".
            "(or otherwise do what you need to do).\\n\\n".
            "You may need to rearrange files to use copy-* though, as those scripts\\n".
            "only look for \$top/*/*.bz2 files.\\n\\n");

        # We move thid to DONE since we are not running copy-SPEED here, which
        # usually does that move.
        \$terminate = 1;
        # No longer renaming topdate ever too confusing, no need with GEN3s anyway
        #rename("\$top/\$opdir/","\$top/DONE/".basename(\$opdir));
        #symlink("\$top/DONE/".basename(\$opdir),"/current");
    } else {
        \$terminate = -1;
    }
}

# OP IS DONE
if (\$terminate > 0) {
    printboth(
      \`ls -alu /share/down/\$tarball /share/down/op*\`.
      "\\n\\n\\nThe Unix tarball above has been accessed by the Windows station. There is probably no need to\\n".
      "push the data forward separately here, as the Windows station takes care of that.\\n\\n".
      "If you DO need time on this station, you can ^C the scrub process and take as much time as you like.\\n".
      "The next op will complete the scrub of this and that op's data.\\n\\n"
    );
} else {
    # Push data
    printboth("Pushing data via:   \$pushcmd\\n\\n");
    while (1) {
        unlink("/tmp/testpush");
        system("\$pushcmd 2>&1 | tee /tmp/testpush | tee -a \$logfile");
        \$pushresult = myreadfile("/tmp/testpush");
        dbg("Just pushed tracker with \$trackpush, returned\nBEGINPUSH\n\$pushresult\nEOFPUSH");
        printboth(\$pushresult,"LOGONLY");
        if (\$pushresult =~ /DID NOT ARRIVE SUCCESSFULLY/) {
            freshsteptracker("pushFAILED",\$projectnamelower);
            my \$ans = getinput(
                "\\n\\n\\n\$COLOR_FAILURE\\n\\nTHAT FAILED!!\\n\\n\\n".
                "Do you want to try again? Maybe fix your $PRIVATEETHER interface (with Suite-Select-Linux)?"
                );
            last unless (\$ans =~ /^y/i);
        } else {
            freshsteptracker("pushed",\$projectnamelower);
            last;
        }
    }
}

#system("iptables -F");
#print "Flushing iptables rules...done\\n\\n";

chdir("/tmp");
# copy-* push above moved our dir into DONE. Fix /current link to point there.
#unlink("/current");
#symlink("\$top/DONE/".basename(\$opdir),"/current");

donereboot();


# BELOW REMAINING LINES ARE OLD AND NO LONGER HIT AS WE JUST REBOOTED

printboth("$PROG (v.$SCRUBVER) is done. You can now:\\n\\nreboot\\n\\n\\n");
\$tmp = rand(20100) ;
if (\$tmp < 10000) {
 \$msg = "RABBIT SEASON!";
} elsif (\$tmp < 20000) {
 \$msg = "DUCK SEASON!";
} else { # this is only 0.5% of the time
 \$msg = "SHOOT ME NOW!";
}

system("HISTFILE= HISTSIZE= HISTFILESIZE= $TERM -name tcp -title \"\$msg\" -display $TCPDISPLAY -geometry 100x25-0-0 -e bash &");
\$| = 1; # unbuffered output
while (1) {
  sleep 25;
  printboth("\\a");
}

sub roomlookup {
  %tennets = (
    "10.0", "North",
    "10.10","South",
    "10.20","East",
    "10.30","West",
    "10.1" ,"North-new",
    "10.11","South-new",
    "10.21","East-new",
    "10.31","West-new",
  );

  while (\$locnum < 26) {
    \$locs{\$locnum} = \$locnum;
    \$locnum++;
  }
  my (\$loc,\$room) = split(/[\n\r]+/,(myreadfile("/site.txt")));
  if (\$genthree) {

    (\$room,\$loc) = \$gbl_genthreesuite =~ m,(\d+-\d+)-(\d+),;
    (\$loc,\$room) = split(/[\n\r]+/,(myreadfile("/mnt/hgfs/host/site.txt")))
      unless (\$loc and \$room);
    \$room = \$genthreesuite unless \$room; # OR:     \$room = \$genthreesuite unless \$room;  ???

    my \$more = "";
    while (\$room !~ /^\d+\-\d+$/) {
      (undef,\$room) = mygetinput
        (\$more.
         "You are on a GEN3 station (\$genthree).\n\n".
         "Where are you (Room-Station)?");
      \$more = "\n\$COLOR_FAILURE\n\nINVALID ANSWER\$COLOR_NORMAL\n\nTry Again.\n\n";
    }
    while (!\$locs{ucfirst \$loc}) {
      my \$more = "";
      (undef,\$loc) = mygetinput
        (\$more.
        "locs{\$loc}=\$locs{\$loc}=\n".
         "This is not good. On GEN3 stations, /mnt/hgfs/host/site.txt is supposed to exist.\n\n".
         "What is your site (North, South, East, West, etc., or its integer)?");
      \$more = "\n\$COLOR_FAILURE\n\nINVALID ANSWER\$COLOR_NORMAL\n\nTry Again.\n\n";
    }
  } else { #Genolder
    #TODO: Implement room lookup, returns ##-##, room-station.
    while (\$room !~ /^\d+\-\d+$/) {
      (undef,\$room) = mygetinput
        (\$more.
         "Where are you (Room-Station)?");
      \$more = "\n\$COLOR_FAILURE\n\nINVALID ANSWER\$COLOR_NORMAL\n\nTry Again.\n\n";
    }
    my \$tennet = 0;
    \$loc = "$OLDSITE" if ("$OLDSITE");
    unless (\$locs{ucfirst \$loc}) {
        unless (\$ethprivaddr) {
            (\$ethprivaddr) =
                \`ifconfig $PRIVATEETHER | grep inet.addr\` =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s/ ;
            (\$ethpubaddr) =
                \`ifconfig $PUBLICETHER | grep inet.addr\` =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s/ ;
        }
        (\$tennet) = \$ethprivaddr =~ /^(\d+\.\d+)/;
        \$loc = \$tennets{\$tennet} if defined  \$tennets{\$tennet} ;
    }
    while (!\$locs{ucfirst \$loc}) {
      my \$more = "";
      my (undef,\$loc) = mygetinput
        (\$more.
         "What is your site (North, South, East, West, etc., or its integer)?");
      \$more = "\n\$COLOR_FAILURE\n\nINVALID ANSWER\$COLOR_NORMAL\n\nTry Again.\n\n";
    }
  }
  my \$locnum = \$locs{ucfirst \$loc};
  newhostvar("gbl_gensuite","\$room-\$locnum");
  newhostvar("gbl_gensite",\$loc);
  if (\$genthree) {
    newhostvar("gbl_genthreesuite",\$gbl_gensuite);
    \$genthreesuite = \$gbl_genthreesuite;
  }
  return(\$room,\$locnum,\$loc);
}
# roomlookup


sub docommandline {
  # May or may not return, set this to exit
  my \$exitdone = 0;


  printlog("In docommandline(@_)\n");
    
  \$def_u = "DEPLOYED";
  \$def_s = "SUCCESSFUL";

  my %toolusage = (
        "DEPLOYED",1,
        "EXERCISED",1,
        "INSTALLED",1,
    );
  my %toolstatus = (
        "SUCCESSFUL",1,
        "UNSUCCESSFUL",1,
    );

  \$usagetextcomingsoon="

  -t FILE    Log one or more tools (see also -s). The file must be in the
             usual etc/VERSION format, namely (one per line):
                    TOOL platform vVERSION
             e.g.:  STOICSURGEON sparc-sun-solaris2.9 v1.4.34.2

  -s STATUS  Status of logged tool(s). Defaults to \$def_s, must be one of:\n".
    "                          ".
    join("\n                          ",sort keys %toolstatus)."\n
  -u USAGE   What the tool use was. Defaults to \$def_u, must be one of:\n".
    "                          ".
    join("\n                          ",sort keys %toolusage)."\n
";
    my \$newvalue = shift @ARGV;
    usage() if (\$opt_h or
                \$opt_v or
                (@ARGV > 1 and \$optcount == 1) or
                (\$newvalue and \$optcount > 1));

    \$toolusage  = defined \$opt_u ? uc \$opt_u : \$def_u ;
    \$toolstatus = defined \$opt_s ? uc \$opt_s : \$def_s ;

    mydie("Not a valid usage: -u \$toolusage")
        unless (\$toolusage{\$toolusage});

    mydie("Not a valid status: -s \$toolstatus")
        unless (\$toolstatus{\$toolstatus});

# opuser() sets \$gbl_opuser and \$gbl_oppasswd gobals
opuser(-1,1); # 2nd arg ==> no password yet
@opusers = (\$gbl_opuser);

    if (\$opt_V) {
        my \$label = "V:" if \$optcount > 1;
        my @results = reverse verval(\$opt_V);
        printboth("\$label@results\n");
        \$exitdone++;
    }

    if (\$opt_t) {
        mydie("Not yet implemented");
    }

    if (\$opt_T) {
        my \$label = "T:" if \$optcount > 1;
        if (\$gbl_targets) {
            print "\${label}Targets section:\$gbl_targets\\n\\n";
        } else {
            mydie("Targets section not yet populated--have you saved your opnotes?\n");
        }
        if (\$gbl_modifiedtargets) {
            print "Modified targets section:\\n".
                  \$gbl_modifiedtargets .
                  "\\n";
        }
        \$exitdone++;
    }

    if (\$opt_M) {
        my \$label = "M:" if \$optcount > 1;
        my @a = bwsofar();
        print "\$label\$a[0]\n" if (@a);
        \$exitdone++;
    }

    if (\$opt_S) {
        my \$label = "S:" if \$optcount > 1;
        if (\$newvalue) {
	  mydie("Schedule ID \$newvalue is not valid, must be 14 digits")
	    unless (\$newvalue =~ /^\d{14}\$/);
	  newhostvar("gbl_opschedule",\$newvalue);
          mydie("Now set in \$global_varfile: ".\`grep gbl_opschedule \$global_varfile\`."\n\n".
                "Fix your opnotes with these vi commands now (ESCape out of insert mode first):\n\n".
	        "  mx\n".
	        "  :%s\#OPSCHEDULE=.*\#OPSCHEDULE=\$gbl_opschedule\#g\n".
	        "  \`x\n");

        }
        if (\$gbl_opschedule and \$gbl_opschedule ne "UNKNOWN") {
            printboth("\$label\$gbl_opschedule\n");
            \$exitdone++;
        } else {
            mydie("Schedule ID not yet set\n");
        }
    }

    if (\$opt_O) {
        my \$label = "O:" if \$optcount > 1;
        if (\$newvalue) {
	  mydie("Operator ID \$newvalue is not valid, must be one or more comma delimited five digit integers")
	    unless (\$newvalue =~ /^\d{5}(,\d{5}){0,}\$/);
	  newhostvar("gbl_opuser",\$newvalue);
          mydie("Now set in \$global_varfile: ".\`grep gbl_opuser \$global_varfile\`."\n\n".
                "Fix your opnotes with these vi commands now (ESCape out of insert mode first):\n\n".
	        "  mx\n".
	        "  :%s\#OPUSER=.*\#OPUSER=\$gbl_opuser\#g\n".
	        "  \`x\n");

        }
        if (\$gbl_opuser) {
            printboth("\$label\$gbl_opuser\n");
            \$exitdone++;
        } else {
            mydie("User ID not yet set\n");
        }
    }    
    if (\$opt_P) {
        my \$label = "P:" if \$optcount > 1;
        if (\$newvalue) {
          \$newvalue = uc \$newvalue;
	  mydie("Project name \$newvalue is not valid, must be alpha, digits and underscore only")
	    unless (\$newvalue =~ /^[A-Z][A-Z0-9_]+\$/);
          opproject(\$newvalue);
          mydie("Now set in \$global_varfile: \n".
                \`egrep \"gbl_(opproject|project|genthreeopname)\" \$global_varfile\`."\n\n".
                "Fix your opnotes with these vi commands now (ESCape out of insert mode first):\n\n".
	        "  mx\n".
	        "  :%s\#OPPROJECT=.*\#OPPROJECT=\$gbl_genthreeopname\#g\n".
	        "  \`x\n");

        }
	my \$projoutput = "";
        if (\$gbl_genthreeopname) {
            \$projoutput .= "\$label\$gbl_genthreeopname (per gen3opname)\n";
            \$exitdone++;
	}
	if (\$gbl_opproject) {
            \$projoutput .= "\$label\$gbl_opproject (per opproject)\n";
            \$exitdone++;
        }
        if (\$projoutput) {
            printboth(\$projoutput);
        } else {
            mydie("Project not yet set\n");
        }
    }    
    if (\$opt_H) {
        my \$label = "H:" if \$optcount > 1;
	my \$mysite = \$locs{\$genthreesite};
	my \$ans = "\$genthreehost,\$genthreesuite,\$mysite";
        \$ans =~ s/-/,/g;
	if (\$ans =~ /^\d+,\d+,\d+,\d+$/) {
            print "\$label\$ans\n";
            \$exitdone++;
        } else {
            mydie("Host/suite information unavailable\n");
        }
    }
    exit 0 if \$exitdone;
}

sub nondatafiles {
  # Sets \$filesarrref to be the list of all non-data files,
  # returns hashed array:   %ipfiles set with
  #    \$ipfiles{\$ip} = list (with newlines) of all files that match that IP
  #                      skipping a bunch we know are not op data (our stuff, that is)
  #                      with any containing 127.0.0.1 highlighted in red.
  #
  local (\$override,\$filesarrref,@dirs) = (@_);
  dbg("Inside nondatafiles(@_)");
  @\$filesarrref = split(/\n/,\`find @dirs -type f 2>/dev/null\`);
  unless (\$override) {
    @\$filesarrref = grep ! m,/down/, , @\$filesarrref;
    @\$filesarrref = grep ! m,/pcaps/, , @\$filesarrref;
    @\$filesarrref = grep ! m,/freshstep, , @\$filesarrref;
    @\$filesarrref = grep ! m,/copy-.*log, , @\$filesarrref;
    @\$filesarrref = grep ! m,/dammit, , @\$filesarrref;
  }
  dbg("nondatafiles(0,\$filesarrref,@dirs) set filesarrref=(@\$filesarrref)");
  foreach (@\$filesarrref) {
    # Flag as maybe data worth keeping if it has an IP in it
    next unless /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/;
  dbg("\$_ may have an IP!");
    my \$ip = \$1;
    my (\$nocolor,\$warncolor) = ();
    if (\$ip eq "127.0.0.1") { 
      \$warncolor = \$COLOR_FAILURE;
      \$nocolor = \$COLOR_NORMAL;
    }
      
    # Except do not flag on our own tool names, some have versions that have
    # four "octets".
    next if /ftshell|tipoff|ourtn|Decode|Dewdrop|exactchange|elatedmonkey|Dubmoat|enemyrun|epoxyresin|eleganteagle/;
    next if m,/(orleansstride|morerats|jscanner_pkg|varkeys|stoicctrls|suctioncharagents|crypttool|enemyrun|suctionchardecodes|dewdrops)/,;
    next if m,/up/(.*noserver|orleansstride|.keystr|toast|itime|crypttool|enemyrun|curse),;
    next if m,/current/tmp/,;
    next if m,\$opdate/tmp/,;
    next if m,/bin/(esna-),;
    next if m,/doc/(sha1sums),;
    next if m,/etc/(gs\\.|auto),;
    \$ipfiles{\$ip} .= "\$warncolor\$_\$nocolor\\n";
  }
  return %ipfiles;
}

sub shredstuff {
    local(\$override,@shreddirs) = (@_);

    # Inside \$shreddir, wipe all files, skip those that contain some strings
    # (unless \$override is set),


    # Remove all links
    my @links = split(/\n/,\`find @shreddirs -type l\`);
    dbg("unlink(@links);");
    printboth("\n\nRemoving ".scalar @links." soft links in @shreddirs.\n");
    unlink(@links);



    # Width of getopdata xterm (which has -geometry 207x56+1+0)
    my \$getopwinwidth = 207;
    # Subtract 7 for the fixed printf characters, 130 for the filename length 
    my \$graphicwidth = \$getopwinwidth - 7 - 130 ;
    my @allfiles = ();
    my %ipfiles = nondatafiles(\$override,\@allfiles,@shreddirs);
    my \$count = @allfiles;
    my \$more = " (skipping those in /down/ or /pcaps/ and /freshstep* files)" unless \$override;
    printboth(".\n\n".
              "Shredding \$count files in @shreddirs\$more.\\n\\n".
              "Will reboot when done.\n\nProgress:\n");
    dbg("Shredding \$count files:\\n\\n".
        join("\\n",@allfiles));
    my \$done = 0;
    my \$shortfile;
    my \$iterations = 1;
    foreach my \$file (@allfiles) {
        \$shortfile = \$file;
        \$shortfile =~ s,$TOP,.,g;
        if (length \$shortfile > 130) {
            \$shortfile = substr(\$shortfile,-130);
            \$shortfile =~ s,^...,...,;
        }
        \$file =~ s,\\$,?,g;
        printf "\r%3d%% %s %-130s",
            int(100*(\$done/\$count)),
            graphic(\$done,\$count,\$graphicwidth),
            \$shortfile;
#OR MAYBE:        \`shred --size 250K --force --remove --zero \$file 2>/dev/null\`;
        dbg("        shred --force --remove --zero --iterations \$iterations \"\$file\" 2>/dev/null");
        \`shred --force --remove --zero --iterations \$iterations "\$file" 2>/dev/null\`;
        \$done++;
    }
    \$done = \$count = 1;
    printf "\r%3d%% %s %-130s\n\n",
            int(100*(\$done/\$count)),
            graphic(\$done,\$count,\$graphicwidth),
            "";


    # This directory has \$ in filenames which can mess up shred. If any
    # left, just remove them with rm -rf.
    printboth("\n\nRemoving \$topdate/bin/jscanner_pkg (if any files have odd characters in them).\n");
    print \`rm -rvf \$topdate/bin/jscanner_pkg 2>&1 | tee -a \$logfile 2>/dev/null\`;



    # Remove all empty dirs above scrub created
    my @dirs = sort by_path_depth split(/\n/,\`find @shreddirs -type d\`);
    dbg("unlink(@links);");
    printboth("\n\nRemoving ".scalar @dirs." empty directories now in @shreddirs\n");
    foreach (@dirs) {
        rmdir ;
    }

    return \$count;
}

sub discoverips {
    local(\$opnotesfile,\$comment,\$which) = (@_);
    \$comment = "quiet" unless \$comment;
    # Set globals %unknownIPdirs, %unknownIPnotes and %addrdirs
    (%unknownIPdirs,%unknownIPnotes,%addrdirs,
    %winhosts,%successfulwinhosts,\$alltargets,
     %routerhosts,%fwhosts,%nonstdhosts,%notdonehosts,%canopyhosts,
    %nofilename) = ();
    # Get IP addresses from collection on disk
    return unless (opendir(GETOPDIR,"\$opdown"));
    my @downfiles = grep ! /^\.{1,2}$/ , readdir(GETOPDIR);
    closedir(GETOPDIR);
    foreach my \$line (@downfiles) {
        next unless (-d "\$opdown/\$line" or
                     \$line =~ /(firewall.log|router.log|script\S*router|script\S*firewall)/);
        (\$ip) = \$line =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\$/;
        (\$ip) = \$line =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})[._a-z]+/i unless (length \$ip);
        (\$ip) = \$line =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/ unless (length \$ip);
        # so \$ip might be wrong if HOST.IP ends in a numeral, this fixes that.
        \$ip = \$1 if (length \$ip and  \$line =~ /\d+\.(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/);
        next unless \$ip;
        \$addrdirs{\$ip} .= "  \$line\n";
    }

    # Populate %addrnotes from \$opnotesfile if we can
    if (open(OPNOTESIN,"\$opnotesfile")) {
        %addrnotes = ();
        # Need to find \$maxindent and \$maxdns before our last time through
        # opnotes.txt, so that processline can fix the indenting and
        # columnizing in \$modifiedtargets section.
        \$maxindent = 0;
        \$maxdns = 0;
        while (<OPNOTESIN>) {
          last if (/^Results/i);
          next if (/^ALIAS:/i);
          if (my (\$ip) = /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s/) {
            my (\$fqdn) = /\$ip\S*\s+(\S+)/;
            \$maxdns = length(\$fqdn) if length \$fqdn > \$maxdns;
            \$indented = index(\$_, \$ip);
            \$maxindent = \$indented if \$indented > \$maxindent;
          }
        }
        # Rewind to front of file again
        seek(OPNOTESIN,0,0);

        # Get IP addresses from targets section of notes
        \$attarglist = 0;
        \$foundtargets = 0;
        \$opnoteslinenum = 0;
        \$originaltargets = "";
        \$modifiedtargets = "";
        while (<OPNOTESIN>) {
            \$opnoteslinenum++;
            next if (/^alias:/i);
            \$attarglist = 1 if (/^Targets/i);
            next unless \$attarglist;
            last if (/^Results/i); # end of target list
            \$ip = "";
            if (\$ip = processline(\$_,\$comment,\$which)) {
                  \$foundtargets = 1;
                  \$addrnotes{\$ip} = 1;        
            }
        }
        close(OPNOTESIN);
    }


    # Compare with IP addresses from both opnotes (%addrnotes)
    # and \$opdown dirs/scripts, see if they match
    foreach \$addr (sort keys %addrnotes) {
        next if (\$addrdirs{\$addr} or \$notdonehosts{\$addr} or \$winhosts{\$addr});
        \$unknownIPnotes{\$addr} = \$addrnotes{\$addr};
    }
    foreach \$addr (sort keys %addrdirs) {
        next if (\$addrnotes{\$addr});
        \$unknownIPdirs{\$addr} = \$addrdirs{\$addr};
    }
}

sub freshsteptracker {
    # NOTE: as of 17 DEC, \$project can be EITHER a project name
    #       or the schedule ID.
    local (\$which,\$project) = (@_);
  # See if we know the current project, prompt if not
  my \$trackerupdate = \$which =~ /update/;
  \$tracker_updates_sent++ if (\$which =~ /update/);
  (\$standard,
    \$successful,
    \$targets,@projectlist,%projecthash) = ();
  (\$project,\$targets,@projectlist) =
    opnotesprojects(\\%projecthash);
  unless (\$project) {
    if (!\$project and \$projectnamelower) {
        \$project = \$projectnamelower;
    } else {
        my \$more = "";
      while (!\$project) {
        \$project = getinput
            (\$COLOR_FAILURE.
             \$more.
             \$COLOR_NOTE.
            "What is your project name?",\$project);
         if (\$project =~ /^\d+\$/) {
           if (length \$project != 14) {
                \$more = "\\nYour Op Schedule ID must be 14 digits.\\n\\n";
                \$project = "";
           }
         }
      }
    }
  }
  my \$todaystamp = timestamp(short);
  unless (\$suite > 0 or !open(TRACKERIN,"/suite.txt")) {
    while (<TRACKERIN>) {
      chomp;
      \$suite = \$_;
    }
  }
  close(TRACKERIN);
  if (\$genthree) {
    \$suite = myreadfile("/tmp/suitefile");
  } else {
    unless  (\$suite =~ /^\d+\$/) {
      \$suite = getinput
        (\$COLOR_NOTE.
         "What is your suite number?",\$suite);
      if (open(TRACKERSUITE,">/suite.txt")) {
        print TRACKERSUITE "\$suite\n";
      }
      close(TRACKERSUITE);
    }
  }
    
    my \$val = myreadfile("/tmp/suiteinfo","/suite.txt");
    if (\$val) {
        newhostvar("gbl_suiteinfofile",\$val);
    }
    # Set the gbl_suiteinfo global at top and bottom of op
    newhostvar("gbl_suiteinfo","\$suite/\$ethprivaddr")
        if (\$suite or \$ethprivaddr);


  my \$freshstepdir = "$TOP/freshstep_\$datedir";
  preservefile(\$freshstepdir);
  \`mkdir -p \$freshstepdir\`;
  \$operlist = join(",",@opusers);
  if ("$PRIVATEETHER" and !\$ethprivaddr) {
    (\$ethprivaddr) =
        \`ifconfig $PRIVATEETHER | grep inet.addr\` =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s/ ;
    newhostvar("gbl_internalIP","\$ethprivaddr") if (\$ethprivaddr);
  }
  my \$hostsuite = \$suite;
  #\$hostsuite = \$gbl_genthreesuite if (\$gbl_genthreesuite  =~ /\d+\-\d+\-\d+/);
  #\$hostsuite = "\$gbl_genthreehost-\$hostsuite" if (\$gbl_genthreehost);
  # \$hostsuite =~ s/-/,/g;
  my \$myproject = \$project;
  \$myproject = \$gbl_genthreeopname if \$gbl_genthreeopname;
  \$trackerfile =
    "\$freshstepdir/freshstep_tracker_\${myproject}_\${which}_\${todaystamp}_\${operlist}_\${hostsuite}_\${ethprivaddr}";

  if (\$which eq "stop") {
    \$which = "end";
    my \$default = "Y";
    my \$successmore = "";
    if (scalar(keys %successfulips) <= 1) {
      \$default = "N" unless \$gotwinbox;
      if (\$gotwinbox) {
          \$successmore = " (assuming\$COLOR_FAILURE YES\$COLOR_NORMAL since you have windows targets)";
          \$default = "Y";
      }
    }
    \$successful = "successful";
    \$ans = getinput("\n\nWas this a successful op\$successmore?",\$default);
    \$successful = "unsuccessful" unless (\$ans =~ /^y/i);
  
    \$standard = \$nonstandard ? "nonstandard" : "standard" ;

    # Compute oplength in minutes, first seconds + 30 (round up), then /60
    \$oplength = scalar time() - \$gbl_opstarttime + 30;
    \$oplength = int(\$oplength/60);

    \$trackerfile .= "_\${successful}_\${standard}_\${oplength}_\${opmegs}M";
  }
  preservefile(\$trackerfile);
  if (open(TRACKEROUT,">\$trackerfile")) {
    \$freshstep_contents = "";
#    my \$trackpush = "bzip2 \$trackerfile ; ls -al \$trackerfile.bz2 ; \$topdate/$TOOLS/copy-fast NOZIP FORCE QUIET \$trackerfile.";
    my \$trackpush = "ls -al \$trackerfile ; copy-fast NOZIP FORCE QUIET \$trackerfile";
    printboth("
Logging \${which} of op via copy-fast:

\$trackpush

")
       unless \$trackerupdate;
        #Get our setup details set by mz -s
        my \$fgsetup=readfile("$TOP/fg/localCopy/fg.log");
        # If we have defined this var at this point (within getopdata), add on the opschedule which is SH specific
        if ( \$fgsetup=~/./ ) { \$fgsetup = "\$fgsetup OPSCHEDULE \$gbl_opschedule"; }
    trackerlog(
                "TRACKER_TYPE",\$which,
                "GMT",scalar gmtime(),
                "GMTEPOCH",scalar time(),
                "SCRUBVER","$SCRUBVER",
                "PROG","$PROG",
                "OS","$OS",
                "OSVERSION","$OSVERSION",
                "opminutes","\$oplength",
                "PUBLIC_INTERFACE","$PUBLICETHER",
                "PUBLIC_IP","$PUBLICIP",
                "PRIVATE_INTERFACE","$PRIVATEETHER",
                "PRIVATE_IP","\$ethprivaddr",
                "FGSETUP","\$fgsetup",
        );
    newhostvar("gbl_targets","\n\$gbl_targets")
      unless (\$gbl_targets =~ /^\n/);
    newhostvar("gbl_modifiedtargets","\n\$modifiedtargets")
      if (\$modifiedtargets);
    newhostvar("gbl_genthreesuite",\$genthreesuite)
      if (\$genthreesuite);
    trackervarlog(# This puts "variable=\$variable" there for each variable
                  # name sent. That is the name=value of each perl variable
                  # whose name is sent. All are treated as strings, with the
                  # right hand side in double quotes (and quotes in the value
                  # properly escaped).
                "gbl_opstarttime",
                "gbl_opstartdate",
                "gbl_opstarttimestr",
                "gbl_callbackresets",
                "gbl_callbackinterval",
		"gbl_checkallin",
                "gbl_pitchcheckin",
                "gbl_publiccheckin",
                "gbl_suite",
                "suite",
                "opmegs",
                "oplength",
#                "project",  # Removed AUG 2012, see gbl_project below.
                "successful",
                "specialproc",
                "standard",
                "operlist",
                "trackerfile",
                # NOTE: All gbl_NAME variables sent to trackervarlog() are logged as BOTH
                #       gbl_NAME=VALUE and NAME=VALUE. 
                "gbl_opuser",
                "gbl_opusertag",
                "gbl_opschedule",
                "gbl_localip",
                "gbl_project",
                "gbl_suiteinfo",
                "gbl_suiteinfofile",
                    "gbl_gensite",
                    "gbl_gensuite",
                    "gbl_genthreesite",
                    "gbl_genthreehost",
                    "gbl_genthreeopname",
                    "gbl_genthreesuite",
                "gbl_externalIP",
                "gbl_gotproblems",
                "gbl_targets",
                "gbl_modifiedtargets",
                "gbl_nopenips",
                "gbl_nopenconnect",
                "gbl_nopenhops",
                "gbl_nopenburned",
                "gbl_nopenhosts",
                "gbl_projectshash",
                "gbl_aliases",
                "gbl_depthhash",
                "gbl_hostnamehash",
                "gbl_statushash",
                "gbl_typehash",
                "gbl_commentshash",
                "gbl_targetline",
                "gbl_pitchips",
                "gbl_spooffrom",
                "gbl_pushedvia",
                "fgfreshen",
                "gbl_fg_reuse",
        );
        
    if (\$which eq "end" or \$which eq "stop") {
        newhostvar("gbl_opstopdate",\$todaystamp);
        newhostvar("gbl_opstoptime",time());
        newhostvar("gbl_opstoptimestr",gmtime());
        trackerlog ("gbl_opstopdate",\$todaystamp,
                    "gbl_opstoptime",time(),
                    "gbl_opstoptimestr",scalar gmtime(),
        );
    }
    # Log even more, target specific
    # First read in varfiles
    # Do global first (someone else may have reset a global since I set it in \$hostvarfile)
    do \$global_varfile if (-s \$global_varfile);
    # Do mine last
    do \$hostvarfile if (-s \$hostvarfile);
    # Not sure here if \$nopen_rhostname or \$nopen_myip is the key
    # for these, so here we start with \$hostip, the key of gbl_nopenhosts
    # which has both (from \$nopen_rhostname), then use whichever \$str
    # of the two we find that has a value, if any.
    foreach my \$hostip (keys %gbl_nopenhosts) {
        my \$str = "";
        my (\$ip) = \$hostip =~ /.*(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s*$/ ;
        trackerlog("TRIGGER_\$hostip","\$str")
            if (\$str = \$host_trigger{\$ip} or
                \$str = \$host_trigger{\$hostip});
        trackerlog("UNAME_\$hostip","\$str")
            if (\$str = \$host_uname{\$ip} or
                \$str = \$host_uname{\$hostip});
        trackerlog("WUPTIME_\$hostip","\$str")
            if (\$str = \$host_wuptime{\$ip} or
                \$str = \$host_wuptime{\$hostip});
        trackerlog("FQDN_\$hostip","\$str")
            if (\$str = \$host_fqdn{\$ip} or
                \$str = \$host_fqdn{\$hostip});
        trackerlog("IPLIST_\$hostip","\$str")
            if (\$str = \$host_iplist{\$ip} or
                \$str = \$host_iplist{\$hostip});
        trackerlog("MACLIST_\$hostip","\$str")
            if (\$str = \$host_maclist{\$ip} or
                \$str = \$host_maclist{\$hostip});
        trackerlog("HIDDENDIRLIST_\$hostip","\$str")
            if (\$str = \$host_hiddendirlist{\$ip} or
                \$str = \$host_hiddendirlist{\$hostip});
    }

    close(TRACKEROUT);
    unlink("/share/down/hostvars.global") ;
    copy(\$global_varfile,"/share/down/hostvars.global") ;
    \`chmod a=rw /share/down/hostvars.global\`;
    preservefile("\$topdate/$DOWN/\$opdonebyfile");
    if (open(OPDONEOUT,">\$topdate/$DOWN/\$opdonebyfile")) {
        print OPDONEOUT \$freshstep_contents;
    }
    close(OPDONEOUT);
    \`sync ; cp -p \$topdate/$DOWN/op.done.by* /share/down/ 2>/dev/null ; cp -p \$topdate/$DOWN/op.done.by* \$topdate/  2>/dev/null\`;

    dbg("IN freshsteptracker(@_) with TOP=\$top DATE=\$datedir\n".
        "RUNNING: \$trackpush\n".
        "WITH: trackerfile=\$trackerfile trackerupdate=\$trackerupdate and\n\n".
        "ls -alrtd /current\n".
        \`ls -alrtd /current\`.
        "\n\nls -alrt / /current /current/ \$topdate/ $TOP\n".
        \`ls -alrt / /current /current/ \$topdate/ $TOP\`
       );
    #system(\$trackpush);
    my \$pushresult = "";
    unlink("/tmp/testpush");
    if (\$trackerupdate and \$tracker_updates_sent % 4) {
            system("\$trackpush 2>&1 | tee /tmp/testpush | grep ARRIVE");
    } else {
            system("\$trackpush 2>&1 | tee /tmp/testpush");
    }
    \$pushresult = myreadfile("/tmp/testpush");
    my \$more = "TRACKER UPDATE #\${tracker_updates_sent} SENT:\n\n"
      if \$trackerupdate;
    dbg("Just pushed tracker\$more with \$trackpush, returned\nBEGINPUSH\n\$pushresult\nEOFPUSH");
    printboth(\$more.\$pushresult)
       unless (\$trackerupdate and \$tracker_updates_sent % 4);

    if (\$pushresult =~ /DID NOT ARRIVE SUCCESSFULLY/) {
        printboth(
            "\\n\\n\\n\$COLOR_FAILURE\\n\\nTHAT FAILED!!\\n\\n\\n".
            "Will try again in \$otherupdateinterval seconds....\$COLOR_NORMAL\n");
    }
  } else {
    warn "COULD NOT OPEN >\$trackerfile: \$!\n";
    dbg("COULD NOT OPEN >\$trackerfile: \$!\n".
        "SO NOT RUNNING: bzip2 \$trackerfile ; ls -al \$trackerfile*; copy-fast NOZIP MIDOP\n".
        "WITH: trackerfile=\$trackerfile and\n\n".
        "ls -alrtd /current\n".
        \`ls -alrtd /current\`.
        "\n\nls -alrt / /current /current/ \$topdate/ $TOP\n".
        \`ls -alrt / /current /current/ \$topdate/ $TOP\`
       );
  }


  my \$freshstamp = "freshstep_".timestamp(short);
  if (\`ls -al  $TOP/freshstep* 2>/dev/null\` =~ /freshstep/) {
    printboth("Moving $TOP/freshstep* to $TOP/DONE/\$freshstamp:\n\n".
      \`mkdir -pv $TOP/DONE/\$freshstamp ; mv \$mvv $TOP/freshstep* $TOP/DONE/\$freshstamp\`);
  }

}
#freshsteptracker

sub myreadfile {
    if (defined &readfile) {
        return readfile(@_);
    }
    my \$val = "";
    foreach my \$outfile (@_) {
        if (-s \$outfile and open(SCRUBIN,\$outfile)) {
            while (<SCRUBIN>) {
                \$val .= \$_;
            }
            close(SCRUBIN);
        }
    }
    return \$val;
}
#myreadfile

sub trackervarlog {
                  # This puts "variable=\$variable" there for each variable
                  # whose name is sent. All are treated as strings, with the
                  # right hand side in double quotes (and quotes in the value
                  # properly escaped).
                  # NOTE: No longer logs a varname="" line when that variable is not defined.
  local (@varnames) = (@_);
dbg("INSIDE: trackervarlog(@_)");
  foreach my \$name (@varnames) {
    next unless (\$name);
    next if (\$name =~ /passwd/);
    my \$val = eval "\\$\$name";
    if (length \$val) {
        trackerlog(\$name,\$val);
    }
    my \$hval = eval "scalar keys %\$name";
    if (\$hval > 0) {
        my %hash = ();
        eval "%hash = %\$name";
        foreach my \$key (%hash) {
            trackerlog("\$name"."\{\"\$key\"\}",\$hash{\$key});
        }
    }
  }
}
    
sub trackerlog {
  local (@arr) = (@_);
dbg("INSIDE: trackerlog(@_)");
  while (@arr) {
    my \$oldname = "";
    my \$name  = shift @arr;
    if (\$name =~ /^gbl_/) {
        (\$oldname) = \$name =~ /gbl_(.*)/;
    }
    my \$value = shift @arr;
    \$value =~ s,\",\\\\\",g;
    my \$content = " \$name=\"\$value\"\n";
    if (\$oldname) {
        \$content .=" \$oldname=\"\$value\"\n";
    }
    print TRACKEROUT \$content;
    \$freshstep_contents .= \$content;
  }
}

sub donereboot() {
  my (\$how,\$what,\$what2) = ("reboot","reboot","rebooting");
  if (\$genthree) {
    (\$how,\$what,\$what2) = ("init 0","shutdown","shutting down");
    &getinput("\\n\\n".
        "$PROG (v.$SCRUBVER) is done.\$COLOR_FAILURE (GEN3 mode: \$genthree)".
        "Your VM will automatically \$what a few seconds after you HIT RETURN.\\n\\n".
        "\$COLOR_FAILURE       YES YOU MUST HIT RETURN HERE!!!!");
    printboth("About to \$what with \$how...");
    sleep 5;
  } else {
    my \$ans = &getinput("\\n\\n".
        "$PROG (v.$SCRUBVER) is done.\$COLOR_FAILURE ".
        "HIT RETURN TO SCRUB $TOP (takes about 11 minutes)\\n\\n".
        "System will automatically \$what after scrub.\\n\\n");
    # Clean up \$opdir
    shredstuff(0,"$TOP");
  }
  my \$countdown = int(\$_[0]) ;
  \$countdown = \$ans if (\$ans > 0);
  \$countdown = 5 unless \$countdown;
  printboth("\\n\\nWe are \$what2 in \$countdown...\\n");
  while (\$countdown-- > 0) {
    sleep 1;
    printboth("   \$countdown...\\n");
  }
  system(\$how) unless (length "$NEWPROG");
  \$countdown = 300 ;
  printboth("\\n\\nYou were using an RC tarball...giving you more time, \$what2 in \$countdown...\\n(Or just \$what it yourself with:\n\n     \$how\n\nif you want this station and the tester has left.)\\n\\n\\n");
  while (\$countdown-- > 0) {
    sleep 1;
    printboth(gmtime()."   \$countdown...\\n") unless (\$countdown % 30);
  }
  system(\$how) ;
}

sub fixboth {
    local (\$atline) = (@_);
    if (\$atline > 0) {
     \$atline = " +\$atline";
    } else {
      \$atline ="";
    }
    system("xterm -geometry 104x55-640+30 -title \"WINDOWS OP NOTES - opnotes.txt\" -e \"\$editor\$atline \$topdate/$DOWN/opnotes.txt\" &");
    system("xterm -geometry 104x55-0+30 -title \"UNIX OP NOTES - opnotes.bak\" -e \"\$editor\$atline \$topdate/$DOWN/opnotes.bak\" &");
    while (1) {
        last unless \`ps -ef | grep "vim.*opnotes" | grep -v grep\`;
        sleep(2);
    }
    \$ans = getinput("Press Enter to continue Op Notes validation.");
}

sub processline {
# NEW c. NOV 2009: Targets section MUST BE whitespace delimited in this order.
#                  Fields after this are allowed for comment purposes.
#
#--> 10.1.1.1     dns.fqdn.com    projectname    TYPE    STATUS
dbg("In processline(@_)");
  local(\$line,\$comment,\$file) = (@_);
  return "" if (!\$attarglist or \$line =~ /^\s*\#/);
  my \$quiet = \$comment eq "quiet";
  #\$quiet = 1 unless (\$gotwindowsnotes or \$comment =~ /in Unix/);
  my \$finalpass = \$comment =~ /MERGED opnotes/;
  my \$trackerupdate = \$comment =~ /TRACKERUPDATE/;
  my \$origline = \$line;
  \$originaltargets .= \$line;
  chomp(\$line);
  # Anchor the right of the IP with whitespace--so if hostname ends in a digit, we are ok
  my (\$ip) = \$line =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s/;
  unless (\$ip and \$attarglist) {
    return "";
  }
  \$alltargets .= "\$line\n";
  # We force IP to be space delimited from any 'arrow' (-->) on that line
  # and remove non-whitespace, preserving indent column, 
  my \$indented = index(\$line, \$ip)-1 if \$finalpass;
  \$minindented = \$indented if \$minindented < 0;
  # So if the first line has NO indent, bump EVERY line by one to the right:
  \$indented++ if \$minindented == 0;
  \$indent{\$ip} = "-" x \$indented;
  \$indent{\$ip} .= ">";
  # Force first column to be indenting, changed to an arrow,
  # second column to be IP.
  # Need .*? in regexp here so that FQDN can contain IP and not be sucked
  # into the .*?  (? makes it less greedy).
  \$line =~ s/.*?\$ip/\$indent{\$ip} \$ip/;
  my (\$indent2,\$ip2,\$fqdn,\$projectnameinsub,\$type,\$status,@comments)
     = split(/\s+/,\$line);
  \$projectnameinsub = "pitchimpair"
    if \$projectnameinsub eq "p";
  unless (!\$finalpass or \$quiet or \$projectnamefromnotes) {
    unless (lc \$projectnameinsub eq "pitchimpair") {
      my \$default = \$projectnameinsub;
      my @nsrat = grep /^\s*NS.RAT\s*=/ , myreadfile("ARRAY","\$topdate/$DOWN/opnotes.txt");
      if (@nsrat == 1 and (length \$nsrat[0] > 200)) {
        # This accounts for if myreadfile does not properly handle "ARRAY"
        @nsrat = grep /^\s*NS.RAT\s*=/ , split(/\n/,"@nsrat");
      }
      @nsrat = grep ! /nopen/i , @nsrat;
      \$nsrat = "@nsrat";
      \$nsrat =~ s,\s, ,g;
      \$default = "pitchimpair"
          if (!\$nsrat and
              (\$projectnameinsub =~ /^pitc/i or
              \$projectnameinsub =~ /^p.+chimp/i));
      my \$more = "\$COLOR_FAILURE (is it misspelled?)\$COLOR_NORMAL"
          if \$default eq "pitchimpair";
      \$more = " (quite common with \$nsrat)" if \$nsrat;
      \$more = " (not unheard of, just unusual)" unless \$more;
      my \$colorline = "\${COLOR_FAILURE}\$line\${COLOR_NORMAL}" if \$more;
      \$ans = getinput(
        "First Target Line is:\n".
        \$colorline."\n\n".
        "Your first projectname is\$COLOR_FAILURE not\$COLOR_NORMAL pitchimpair\$more.\n\n".
        "\${COLOR_FAILURE}PLEASE CONFIRM\$COLOR_NORMAL: What should the first line project name be?",
        \$default);
        \$projectnameinsub = \$ans if \$ans;
    }
  }
  if (lc \$status eq "not" and \$comments[0] eq "attempted") {
    \$status .= "_attempted";
    shift @comments;
  }
  my \$comments = join(" ",@comments);
  # Lowercase all fields except indent, IP and \$comments
  (\$fqdn,\$projectnameinsub,\$type,\$status) = 
      (lc \$fqdn,lc \$projectnameinsub,lc \$type,lc \$status);
  \$projectnamefromnotes{\$ip} = \$projectnameinsub;

  # Set this global, will be the last line project once done.
  \$projectnamefromnotes = \$projectnameinsub if \$finalpass;
  \$projectlist{lc \$projectnameinsub} = \$ip;

  unless(\$trackerupdate) {
    unless(ipcheck(\$ip2)) {
        mywarn("\\n\\nIGNORING MALFORMED TARGET LINE (no IP in IP column):\$COLOR_NORMAL\\n   \$origline");
        \$malformed++;
        return "";
    }
    
    if (\$projectnameinsub =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/) {
        mywarn("\\n\\nIGNORING MALFORMED TARGET LINE (project column contains IP):\$COLOR_NORMAL\\n   \$origline");
        \$malformed++;
        return "";
    }
  }
  if (\$status =~ /^s/) {
        \$status = "successful";
  } elsif (\$status =~ /^u/) {
        \$status = "unsuccessful";
        \$notdonehosts{\$ip}++;
  } elsif (\$status =~ /^not/) {
        \$status = "not_attempted";
        \$nofilename{\$ip}++;
        \$notdonehosts{\$ip}++;
  } elsif (\$status =~ /^non/) {
        \$status = "nonstandard";
        \$nonstdhosts{\$ip}++;
  } elsif (!\$trackerupdate){
        mywarn("\\n\\nIGNORING MALFORMED TARGET LINE (\$COLOR_NOTE\$status\$COLOR_FAILURE is not a valid status):\\n   \$origline\\n");
        \$malformed++;
        return "";
  }
  TYPETEST:
    if (\$type =~ /^unknown/i) {
        \$type = "unknown";
    } elsif (\$type =~ /^unk$/i) {
        \$type = "unk";
    } elsif (\$type =~ /^[un]/i) {
        \$type = "unix";
    } elsif (\$type =~ /^f/i) {
        \$type = "firewall";
        \$fwhosts{\$ip}++;
    } elsif (\$type =~ /^r/i) {
        \$type = "router";
        \$routerhosts{\$ip}++;
    } elsif (\$type =~ /^c/i) {
        \$type = "canopy";
        \$canopyhosts{\$ip}++;
    } elsif (\$type =~ /^w/i) {
        \$type = "windows";
        \$nofilename{\$ip}++;
        \$winhosts{\$ip}++;
        \$successfulwinhosts{\$ip}++ if (\$status eq "successful");
    } elsif (!\$trackerupdate){
        mywarn("\n\nIGNORING MALFORMED TARGET LINE (\$COLOR_NOTE\$type\$COLOR_FAILURE is not a valid type):\$COLOR_NORMAL\n   \$origline");
        \$malformed++;
        return "";
    }


  \$comment .= " (\$projectnamefromnotes{\$ip})";

#--> 10.1.1.1     dns.fqdn.com    projectname    TYPE    STATUS


#(\$indent2,\$ip2,\$fqdn,\$projectnamefromnotes,\$type,\$status,@comments) = split(/\s+/,\$line);
  \$line = sprintf("%-26s %-30s %-20s %-9s %-13s %s",
    "\$indent2 \$ip2",\$fqdn,\$projectnameinsub,\$type,\$status,\$comments);
  if (\$finalpass) {
    my \$origtype = \$type;
    if (substr(\$type,0,1) eq "u" and \$gbl_nonunix{\$ip}) {
        my \$ans = getinput(
            "\n\n# Problem Target Type \"\$type\" in Line:\n\n".
            "\$line\n\n".
            "This target is labeled \"\$type\", but earlier was seen differently as:\n\n".
	    "    NOPEN_SERVERINFO == \$gbl_nonunix{\$ip}\n\n".
	    "In these cases, usually \"router\" is better.\n\n".
            "What type should this target be?","router");
        \$type = lc \$ans;
        goto TYPETEST unless (\$origtype eq \$type);
    } elsif (\$type eq "unk") {
        my \$ans = getinput(
            "\n\n# Problem Target Type \"unk\" in Line:\n\n".
            "\$line\n\n".
            "This target is labeled \"unk\". Most often, \"unix\" is better.\n\n".
            "What type should this target be?","unix");
        \$type = lc \$ans;
        goto TYPETEST unless (\$origtype eq \$type);
    }
    \$nonstandard .= \$line if (\$line =~ /nonstandard/i);
    \$comment .= " TYPE=\$type";
    if (\$line =~ /\ssuccessful\s/i and !(\$line =~ /\swindows\s/)) {
      \$successfulips{\$ip} = \$line;
      delete \$unsuccessfulips{\$ip};
    } elsif (\$line =~ /\sunsuccessful\s/i and !(\$line =~ /\swindows\s/)) {
      \$unsuccessfulips{\$ip} = \$line;
      delete \$successfulips{\$ip};
      \$comment .= " UNSUCCESSFUL";
    } else {
      # So must be windows, we don't count as either
      delete \$unsuccessfulips{\$ip};
      delete \$successfulips{\$ip};
    }

    \$modifiedtargets .= "\$line\n";
    my \$pitchlinemore = "";
    if (\$opnotespitchlinenum) {
      \$pitchlinemore = " (P+".int(\$opnoteslinenum - \$opnotespitchlinenum) . ")";
    }
  }
  printboth("I found \$ip2 \$comment in \$file line \$opnoteslinenum\$pitchlinemore\\n")
    if (\$comment and !\$quiet);
  return \$ip;
}

sub findindex {
  local (\$str,@arr) = (@_);
  for (my \$i=0;\$i<@arr;\$i++) {
    return \$i if (\$arr[\$i] =~ /\$str/i);
  }
  return -1;
}
# Recursive routine to build the filename of the tarball
sub buildfilename {
        my @argslist = @_;

        # Determine if adding self to filename or more recursion
        my \$myip = \$argslist[0];
        # IP in the tarball filename should be the alias, same one we want it logged as
        \$myip = \$aliasedip{\$myip} if \$aliasedip{\$myip};
        my \$mylevel = \$argslist[1];
        my \$i;
        my \$j;
        my @newargslist;

        return if (\$alreadybuilt{\$myip});
        \$alreadybuilt{\$myip} = 1;

        for (\$i = 2; \$i <= \$#argslist; \$i += 2) {

                if (\$argslist[\$i+1] >= \$mylevel) {
                        @newargslist = ();
                        for (\$j = \$i; \$j <= \$#argslist; \$j++) {
                                \$newargslist[\$j-\$i] = \$argslist[\$j];
                        }
                        buildfilename(@newargslist);
                }
                else {
                        last;
                }
        }

        # If here, now we can tack on info to filename and return
        return if (\$nofilename{\$myip} and !\$unsuccessfulips{\$myip});
	my \$fixproject = lc opproject();
	\$fixproject = \$projectmap{\$myip}
		if (\$projectmap{\$myip});
	
	while (!\$projectmap{\$myip}) {
                printboth("NOTE: This is where new code was added to fix missing project names.\n\n");

        	\$fixproject = getinput
		   ("Please confirm project name for IP \$myip: ",\$fixproject);
		\$projectmap{\$myip} = \$fixproject;
	}
        \$tarballfilename .= "." if (\$tarballfilename);
        \$tarballfilename .= "\$fixproject.\$myip";        
        return;
} #end buildfilename

sub getispinfo {
    local(\$redial) = @_;
    # globals: \$localip

    \$wearedone = "";

    (\$isp,\$city,\$phone) = ("LK");

    \$xispfile = "/root/.xisplast";
    if (-e "/tmp/isp_info") {
        \$ispage = -C _;  # age of file tested last
        #ignore this file if it's older than 1 hour
        if (\$ispage < (1.0/24.0)) {
            if ( open(OPDATA,"< /tmp/isp_info")) {
                #read in file contents into variables
                chomp(\$isp = <OPDATA>);
                chomp(\$city = <OPDATA>);
                chomp(\$phone = <OPDATA>);
            }
            close(OPDATA);
        }
    } elsif (-e \$xispfile) {
        \$ispage = -C \$xispfile;
        #ignore this file if it's older than 1 hour
        if (\$ispage < (1.0/24.0)) {
            (\$isp) = \`tail -2 \$xispfile | head -1\` =~ /:.. [0-9]{4} (.*)\// ;
            (\$city) = \`tail -1 \$xispfile\` =~ /:[0-9]{2} [0-9]{4} (.*) .67/;
            (\$phone) = \`tail -1 \$xispfile\` =~ /:[0-9]{2} [0-9]{4}.*,(.*)/;
        }
    }

    open(ISPINFOOUT,">> \$topdate/$DOWN/ispinfo.txt");
    \$redial = " REDIAL " if \$redial;
    \$num = "1";
  
    my \$waitcount = 0;  
    while (! -e "/tmp/suiteinfo") {
        sleep 1;
        mywarn("You must finish the Suite-Select window first")
            unless (\$waitcount % 45 or -e "/tmp/suiteinfo");
        \$waitcount++;
    }
    sleep 1;
    my \$defaults = \$redial ? "" : " DEFAULTS";
    mywarn("NOTE: Defaults are NOT correct here on modem ops.\n\n")
         if ! \$redial;
    while (! \$wearedone) {
        \$ans = "";
        if (\$redial or ! \$defaults) {
            \$isp     =   &getinput("\$redial\$num ISP Account         : ",\$isp);
            \$city    =   &getinput("\$redial\$num City                : ",\$city);
            \$phone   =   &getinput("\$redial\$num Phone #             : ",\$phone);
            \$localip = &getipinput("\$redial\$num ISP IP              : ",\$localip);
        }

        \$isp = "LK" unless \$isp;

        newhostvar("gbl_localip",\$localip);
        if ( \$ans =~ /^y/i ) {
            print ISPINFOOUT "ISP\$redial\$num:\t\$isp\n".
                "City\$redial\$num:\t\$city\n".
                "Phone\$redial\$num:\t\$phone\n".
                "Source IP\$redial\$num:\t\$ourip\n".
                "ISP IP\$redial\$num:\t\$localip\n";
            \$num++;
            next;
        }

        while (! ( \$wearedone =~ /^[yn]/i ) ) {
            \$wearedone=        &getinput
               ("ISP\$redial\$num:\t\$isp\n".
                "City\$redial\$num:\t\$city\n".
                "Phone\$redial\$num:\t\$phone\n".
                "ISP\$redial\$num IP:\t\$localip".
                "\n\n                Are these\$defaults correct?        : ","Y");
        }
        \$defaults = "";
        if (! ( \$wearedone =~ /^y/i ) ) {
            \$wearedone = "";
	    next;
        }
        \$ans       =   &getinput(" Are there more redials? : ","No")
            if \$redial;
    } #end while (!\$wearedone)
    \$num = "" unless \$redial;

    # Spaces and slashes before ":\t" are removed in
    # variable name when this file is read elsewhere.
    # Use exactly one \t here after :
    #
    print ISPINFOOUT "ISP\$redial\$num:\t\$isp\n".
        "City\$redial\$num:\t\$city\n".
        "Phone\$redial\$num:\t\$phone\n".
        "ISP\$redial\$num IP:\t\$localip";
    if (! \$redial) {
        print ISPINFOOUT "\n".
            "Source IP:\t\$ourip\n".
            "FINAL target IP:\t\$targetip\n".
            "Ops Machine:\t\$host";
    }
    print ISPINFOOUT "\\n";
    close(ISPINFOOUT);

} # end sub getispinfo


sub getinput {
    # NOTE THIS DIFFERS FROM mygetinput() in autoutils, which returns am array.
  local(\$prompt,\$default) = @_;
  local(\$ans,\$tmp) = ("","");
  
  \$tmp = \$default;
  if (chop(\$tmp) eq "\\n") {
    #damn ^M's in script files
    \$default = \$tmp;
  }

  printboth(\$prompt);
  if (\$default) {
    printboth(" [\$default] ");
  } else {
    printboth(" ");
  }
  chomp(\$ans = <STDIN>);
  \$ans = \$default if ( \$ans eq "" );
  printlog("\n\nANSWERED: \\"\$ans\\"\n");
  return \$ans;
} # end sub getinput

sub getipinput {
  local(\$prompt,\$default) = @_;
  local(\$ans,\$tmp) = ("","");
  
  while (! \$ans) {
    \$ans = &getinput(\$prompt,\$default) ;
    if (! length \$ans) {
      printboth("\\n\\n\\aYou must enter a valid IP or \"unknown\" here.\\n\\n");
    } elsif ( ! (\$ans eq "unknown") and ! &ipcheck(\$ans)) {
    \$ans = "";
      printboth("\\n\\n\\aInvalid IP.\\n\\n");
    }
  }
  return \$ans;
} # end sub getipinput

sub printboth {
    my \$logonly = "\$viacopywhat";
    if (\$_[-1] eq "LOGONLY") {
        \$logonly = pop (@_);
    }
    print "@_" unless \$logonly;
    return unless open(LOG,">> \$logfile");
    print LOG "@_";
    close(LOG);
}
#printboth

sub warnherealso {
  return unless open(LOG,">> \$logfile");
#  warn "@_"; autoutils mywarn will call warnherealso() if defined, so no warn here
  print LOG "TOSTDERR: @_";
  close(LOG);
}
#warnherealso

sub printlog {
  return unless open(LOG,">> \$logfile");
  print LOG "@_";
  close(LOG);
}

sub setusagetexts {
  \$usagetext="
Usage: \$prog [OPTIONS]
       \$prog setvar varname [host] [value of var]

When called directly, and after the first (popup) instance has begun,
\$prog now serves a few op related functions. Running it with no arguments
will re-run getopdata as before, but only do so if your original getopdata
is no longer active (or you have killed it).

The setvar capability will define a variable in hostvars.global or the proper
hostvars.HOST.IP  (if the keyword \"host\" appears AND the host data is defined,
which usually means you are running a NOPEN -lsh command). Care must be taken
not to conflict with any variable \"varname\" already in use by other scripts.

Optional host argument puts content in hostvars.nopen_rhostname if that
is defined. To set hashed arrays, use a \\".\\" for each bracket in varname.


When run with these options, \$prog will print the desired information if
available and then exit. If the optional \"newval\" is provided for -O/P/S, that
option must be the only one used and that value is then reset in hostvars.global
and vi pastables are provided to fix your opnotes.txt file.

 -h/v         Prints usage statement/version
 -V VER       Compute a numerically comparable value for a N.M.L.K
              version string. Returns: VALUE STRING, where STRING is the
              N.M.L.K string inside what you sent it.
 -H           Prints this host information numerically as HOST,ROOM,STATION,SITE
 -M           Prints out our current throughput in MB (per bwsofar()).
 -O [newval]  Prints/sets Op User ID
 -P [newval]  Prints/sets Op Project Name
 -S [newval]  Prints/sets Op Schedule ID
 -T           Prints/sets out the Targets section of opnotes.txt (if it is saved).

";

}
GETOPDATA
chmod 700 $TOP/$DATE/$TOOLS/getopdata
### end writing of getopdata ###

note Creating  $TOP/$DATE/$TOOLS/getmorerats
cat <<'MORERATS' > $TOP/$DATE/$TOOLS/getmorerats
#!/bin/bash
BETA=`echo $1 $2 | grep -i beta`
ALPHA=`echo $1 $2 | grep -i alpha`
HAVEALPHAUP=0
HAVEBETAUP=0
[ "$DIR" ] || DIR=/current
[ "$DIR" = "." ] && DIR=`pwd`
if [ "$ALPHA" -a -f "${DIR}/ALPHAwarez/up/morerats.tar.bz2" ] ; then
    HAVEALPHAUP=1
    mv ${DIR}/up/morerats.tar.bz2 ${DIR}/ORIGUP.morerats.tar.bz2 2>/dev/null
    mv ${DIR}/ALPHAwarez/up/morerats.tar.bz2 ${DIR}/up
fi
if [ "$BETA" -a -f "${DIR}/BETAwarez/up/morerats.tar.bz2" ] ; then
    HAVEBETAUP=1
    if [ $HAVEALPHAUP -gt 0 ] ; then
        mv ${DIR}/up/morerats.tar.bz2 ${DIR}/ORIGALPHAUP.morerats.tar.bz2 2>/dev/null
    fi
    mv ${DIR}/up/morerats.tar.bz2 ${DIR}/ORIGUP.morerats.tar.bz2 2>/dev/null
    mv ${DIR}/BETAwarez/up/morerats.tar.bz2 ${DIR}/up
fi
if [ $HAVEALPHAUP -gt 0 -o $HAVEBETAUP -gt 0 ] ; then
    if [ ! -e ${DIR}/etc/autoutils -a ! -e ${DIR}/etc/autodone ] ; then
        if [ -e ${DIR}/*warez/etc/autoutils -a -e ${DIR}/*warez/etc/autodone ] ; then
            echo -e "\nWe have NOPEN in ALPHA or BETA but not in ${DIR}/etc*, so:\n\n"
            echo -e "COPYING contents of \n\a"`ls -ld ${DIR}/*warez`
            echo -e "\nInto ${DIR}/"
            cp -prv ${DIR}/ALPHAwarez/* ${DIR}/ 2>/dev/null
            cp -prv ${DIR}/BETAwarez/* ${DIR}/ 2>/dev/null
        fi
    fi
fi
if [ -f "${DIR}/up/morerats.tar.bz2" ] ; then
    if [ -d "${DIR}/up/morerats" ] ; then
        echo "Setting aside old morerats:"
        mv  ${DIR}/up/morerats ${DIR}/UP.morerats.old.$$
    fi
    if [ -d "${DIR}/bin/morerats" ] ; then
        echo "Setting aside old morerats:"
        mv  ${DIR}/bin/morerats ${DIR}/BIN.morerats.old.$$
    fi
    echo -e "\t${DIR}/up/morerats.tar.bz2"
    sleep 1
    # Background this whole thing inside {}s with stderr NULLd
    # This makes a new morerats/, but if the tarball starts at ./morerats,
    # that gets fixed with the mv commands.
    {
        mkdir -p ${DIR}/up/morerats ${DIR}/bin/morerats
        mv ${DIR}/up/morerats.tar.bz2 ${DIR}/up/morerats
        cd ${DIR}/up/morerats
        tar xjf morerats.tar.bz2
        mv *client* ${DIR}/bin/morerats
        [ -d ${DIR}/bin/morerats/morerats/ ] && mv ${DIR}/bin/morerats/morerats/* ${DIR}/bin/morerats/  && rmdir ${DIR}/bin/morerats/morerats/
        [ -d ${DIR}/up/morerats/morerats/ ] && mv ${DIR}/up/morerats/morerats/* ${DIR}/up/morerats/  && rmdir ${DIR}/up/morerats/morerats/
        chown -hR 0:0 ${DIR}/up/morerats ${DIR}/bin/morerats 2>/dev/null
        (sum `find ${DIR}/up/morerats -type f` ; find ${DIR}/up/morerats -type f -ls ) 2>/dev/null > ${DIR}/up/morerats/sums 
        (sum `find ${DIR}/bin/morerats -type f` ; find ${DIR}/bin/morerats -type f -ls ) 2>/dev/null > ${DIR}/bin/morerats/sums 
    } 2>/dev/null  &
else
    # this saves time later for packrat
    [ -d "${DIR}/up/morerats" ] && (sum ${DIR}/up/morerats/* ; ls -al ${DIR}/up/morerats/* ) 2>/dev/null > ${DIR}/up/morerats/sums &
fi
MORERATS
chmod +x /$TOP/$DATE/$TOOLS/getmorerats 2>/dev/null

note Creating /usr/local/bin/1x and friends
cat <<4X > /usr/local/bin/4x
#!/usr/bin/env perl
# Built $DATE by scrubhands $SCRUBVER
\$display = ":0" ;
\$term = "xterm" ;
\$display = \$ENV{DISPLAY} if ( \$ENV{DISPLAY} =~ /:/ ) ;
\$defargs = "-display \$display -ut +cm +cn -sk -sb -sl 15000 -fg black -bg gray80 -ie";
\$count = 4;
\$count = 1 if (\$0 =~ /1x/);
\$count = 2 if (\$0 =~ /2x/);
\$count = 3 if (\$0 =~ /3x/);
\$exact = (\$0 =~ /xw/);

if (\$ARGV[0] eq "-h") {
  print "
usage:  1x [-s|-w] [extra \$term arguments]   (brings up only 1)
        2x [-s|-w] [extra \$term arguments]   (brings up only 2)
        3x [-s|-w] [extra \$term arguments]   (brings up only 3)
        4x [-s|-w] [extra \$term arguments]   (brings up 4)

This script starts up to four instances of \$term. Default arguments used are:
       \$defargs
       (see man \$term for what those do).

   -s   wait for click on window, then use that size (also done
        when run as something containing \"xs\").

   -w   wait for click on window, then use that size AND location (also
        done when run as something containing \"xw\").

   Soft links for N=1 .. 4 are created for all of Nx, Nxw and Nxs. Running
   as Nxw or Nxs is equivalent to the -w and -s options, respectively.
        examples:

         2xw                     (make two windows identical to clicked one)
         2xs                     (make two windows same size as clicked one
                                  placed in top two corners)
         4x -bg white -fg black  (overrides default colors, one in each corner)
         3x -cm                  (disables colors, three windows in corners)
         4x -rightbar            (scrollbars on right)

";
  exit
} elsif (\$ARGV[0] =~ /^-[ws]\$/ or \$0 =~ /x[ws]/) { 
  print "\\nClick on any window to use that window's size:" ;
  chomp(\$geom = \`xwininfo | grep geometry\`) ;
  \$geom =~ s,.*-geometry\s+,,;
  print "\\n\\n";
  \$geom =~ s,[\+\-].*,, unless \$exact;
}
shift @ARGV if (\$ARGV[0] eq "-s" or \$ARGV[0] eq "-w") ; 

close(STDIN);
close(STDOUT);
close(STDERR);
\$ENV{PROMPT_COMMAND} = "" ;
if (\$count-- > 0 && ! fork()) {
  \$geom .= "+0+0" unless \$exact;
  warn "DBG: RUNNING\n:\$term \$defargs -geometry \$geom @ARGV\n";
  exec "\$term \$defargs -geometry \$geom @ARGV";
} elsif (\$count-- > 0 && ! fork()) {
  \$geom .= "-0+0" unless \$exact;
  warn "DBG: RUNNING\n:\$term \$defargs -geometry \$geom @ARGV\n";
  exec "\$term \$defargs -geometry \$geom @ARGV";
} elsif (\$count-- > 0 && ! fork()) {
  \$geom .= "+0-0" unless \$exact;
  warn "DBG: RUNNING\n:\$term \$defargs -geometry \$geom @ARGV\n";
  exec "\$term \$defargs -geometry \$geom @ARGV";
} elsif (\$count-- > 0 && ! fork()) {
  \$geom .= "-0-0" unless \$exact;
  warn "DBG: RUNNING\n:\$term \$defargs -geometry \$geom @ARGV\n";
  exec "\$term \$defargs -geometry \$geom @ARGV";
}
4X


(   cd /usr/local/sbin
    ln -sf 4x 3x 
    ln -sf 4x 2x 
    ln -sf 4x 1x 
    ln -sf 4x 4xs 
    ln -sf 4x 3xs 
    ln -sf 4x 2xs 
    ln -sf 4x 1xs 
    ln -sf 4x 4xw 
    ln -sf 4x 3xw 
    ln -sf 4x 2xw 
    ln -sf 4x 1xw
)
chmod 700 /usr/local/sbin/4x

if [ "$TESTGETOPDATA" ] ; then
    mkdir -vp  $TOP/$DATE/etc
    cp -vp `dirname $0 2>/dev/null`/../etc/autoutils $TOP/$DATE/etc || \
       cp -vp /current/etc/autoutils $TOP/$DATE/etc
    for PFILE in getopdata doupgrade ethwarn.pl ; do
        echo perl -c $TOP/$DATE/$TOOLS/$PFILE
        perl -c $TOP/$DATE/$TOOLS/$PFILE
    done
    exit
fi


[ -d /usr/local/bin ] && [ ! -L /usr/local/bin ] && mv /usr/local/bin /usr/local/bin.old.$$
[ -d /usr/local/sbin ] || mkdir -p /usr/local/sbin
[ -e /usr/local/bin ] || ln -sf /usr/local/sbin /usr/local/bin
[ -e /usr/local/sbin/lss ] || ln -sf /usr/local/sbin/lsstamp /usr/local/sbin/lss

note "Configuring /etc/vimrc (remove any textwidth= or tw= lines)"
cp -pf /etc/vimrc /etc/vimrc.orig
sed "s/.*tw=.*//" /etc/vimrc.orig | sed "s/.*textwidth=.*//" > /etc/vimrc
echo "set tw=0" >> /etc/vimrc

# See if we need to update the alwayspcap.pl section in /etc/rc.local
RCHEADLINES=`grep -n RCLOCAL /etc/rc.local | head -1 | sed "s/:.*//g"`
cat /dev/null > /tmp/rc.local.new
if [ "$RCHEADLINES" ] ; then
  RCHEADLINES=$((RCHEADLINES-1))
  head -$RCHEADLINES /etc/rc.local > /tmp/rc.local.new
else
  cp -p /etc/rc.local /tmp/rc.local.new
fi
cat <<EOFRCLOCAL >> /tmp/rc.local.new
RCLOCALVER="from scrubhands v.$SUITEVER"
# DO NOT CHANGE BELOW ABOVE LINE. AUTOMATICALLY UPDATED BY scrubhands.
export RCLOCAL=yes
[ -e /etc/rc.d/init.d/functions ] && source /etc/rc.d/init.d/functions 
[ -x /usr/local/bin/alwayspcap.pl ] && echo -n Starting alwayspcap.pl:
[ -x /usr/local/bin/alwayspcap.pl ] && \\
    INTERFACE=$PUBLICETHER RESTART=yes /usr/local/bin/alwayspcap.pl > /dev/null 2>&1 && \\
    [ -e /etc/rc.d/init.d/functions ] && echo_success
if [ \$? -gt 0 ] ; then 
  [ -e /etc/rc.d/init.d/functions ] && echo_failure
  [ -e /etc/rc.d/init.d/functions ] || echo FAILED
else
  [ -e /etc/rc.d/init.d/functions ] || echo OK
fi
echo -e "\n"\`date\` /etc/rc.local FINISHED
unset RCLOCAL
sleep 3
EOFRCLOCAL
diff /tmp/rc.local.new /etc/rc.local || \
    {
    note Updating the alwayspcap.pl section in /etc/rc.local
    cat  /tmp/rc.local.new > /etc/rc.local
    }
rm -f /tmp/rc.local.new


note Configuring root and black .vimrc
cat <<EOF > /root/.vimrc
:map <F5> o<C-R>=strftime("%F %T %Z -- ")<CR>
:map! <F5> <C-R>=strftime("%F %T %Z -- ")<CR>
:set textwidth=0
:syntax off
:set t_kb=
:let splitview=0
:map <F8> :if splitview<CR>let splitview=0<CR>1wincmd w<CR>hide<CR>else<CR>let splitview=1<CR>8split<CR>:5<CR>normal zt<CR>endif<CR><CR>
:map <S-F8> <C-W>W
:map <F9> za
:imap <F9> <ESC>za
:map <S-F9> zi
:imap <S-F9> <ESC>zi
:map <F6> O=======================<CR>---  <CR>=======================<<CR><CR><CR>>=======================<CR><ESC>2kzfi<zo2kA
:imap <F6> =======================<CR>---  <CR>=======================<<CR><CR><CR>>=======================<CR><ESC>2kzfi<zo2kA
:map <S-F6> o=======================<<CR><CR><CR>>=======================<ESC>2kzfi<zo
:imap <S-F6> =======================<<CR><CR><CR>>=======================<ESC>2kzfi<zoo
:map <F10> zkzv
:map <F11> zjzv
:sy region TargetsSection start=/^Targets (IP, full domain name, target tags: pitchimpair unsuccessful not_attempted ) : $/ end=/^Results:$/ contains=CONTAINED keepend
:sy match UnixTargets /^-*>.*nix\s.*/ contained oneline
:sy match WinTargets /^-*>.*win\(dows\)*\s.*/ contained oneline
:sy match FWTargets /^-*>.*\sfw\s.*/ contained oneline
:sy match RTRTargets /^-*>.*\srtr\s.*/ contained oneline
:sy match PitchTargets /^-*>.*\spitchimpair\s.*/ contained oneline
:sy match UnsuccTargets /^-*>.*\suns.*/ contained oneline
:sy match Meta /^\(PROJECT=\|OPUSER=\|OPSCHEDULE=\|SCRUBVER=\|POPMAIL\).*/ oneline
:sy match Meta /^Redirect\(ing Method\| Target [0-9]\| Host [0-9]\).*/ oneline
:sy match Meta /^\(ISP:\|City:\|Phone:\|ISP IP:\|Source IP:\|FINAL target IP:\|Ops Machine:\).*/ oneline
:sy match Meta /^\LOCALHOST.LOCALDOMAIN: scrubhands v..*\n#*\nSCRUBHANDS.*\n:\n\/usr\/local\/bin\/scrubhands.*\n#*/
:syn region CommentBlock start=/^#.*\n#/ end=/^[^#]/me=e-2 fold keepend contains=none
:sy match TimeStamp /^[0-9]\{1,2\}:[0-9][0-9] [AP]M \([0-9]\{1,2\}\/\)\{2\}[0-9]\{4\}/ containedin=TargetResults
:sy match TimeStamp /^[0-9]\{4\}\(-[0-9]\{2\}\)\{2\} \([0-9]\{2\}:\)\{2\}[0-9]\{2\} UTC/ containedin=TargetResults
:hi UnsuccTargets ctermbg=red
:hi UnixTargets ctermfg=darkgreen
:hi WinTargets ctermfg=darkblue
:hi RTRTargets ctermfg=darkmagenta
:hi FWTargets ctermfg=darkred
:hi PitchTargets ctermfg=darkcyan
:hi CommentBlock ctermfg=blue
:hi Meta ctermfg=darkgray
:hi TimeStamp ctermbg=darkyellow
:syn sync fromstart

:map <F12> :echo "\nThis config adds Syntatical highlighting, folding and quick-jump to targets.  Folding can compress a whole section of opnotes to one line that can be expanded as needed without altering the file contents.\n\nNew keybindings:\nF6: Insert target header block\nF8: Toggle targets section split window\nShift-F8: Switch split window focus\nF9: Toggle folding at cursor\nShift-F9: Toggle autofolding (whole file)\nF10: Move to previous target.\nF11: Move to next target\nF12: Help"<CR>
EOF
echo -e "set t_kb=\177" >> /root/.vimrc
if [ -d /home/black ] ; then
    cp -f /root/.vimrc /home/black/.vimrc
fi

# Add lines to /root/.bashrc if not already done
if [[ ! `grep stty /root/.bashrc 2>/dev/null` ]]; then
	echo stty erase ^? >> /root/.bashrc
fi


$SETCOLOR_NORMAL

cd $TOP/$DATE/
unset TARDIR TAR SECONDTRY
while [ ! "$TAR" ] ; do
    if [ "$SECONDTRY" ] ; then

	echo -e "\a

DOH! Couldn't find any valid tarballs on floppy or zip disk. Did you forget 
to put in the right thumb, floppy or ZIP?

$PROG looks first for tar zip disks, then mountable zip disks, 
then tar floppies (no need to type \"zip\" any more).

Put in the media and press RETURN to continue, or ^C to abort.
"
	read junk
	TARKEYS=
	TAR=
	TARBALL=
    else
	SECONDTRY=1
    fi

    TMPCOUNT=0
    rm -f /tmp/zipstatus
    if [ "$TARBALL" ] ; then
	ZIPSTATUS=file
	TAR=$TARBALL
    elif [ "$TAR" ] ; then
	# now looking for zip tarball first
	echo "Looking on /dev/zip for tarball (tar'd there or mountable)"
	TAR=`tar xvf /dev/zip 2>/dev/null`
	unset ZIPSTATUS TARDIR
	ZIPSTATUS=tar
	TARDIR=$TOP/$DATE
    else
	# make sure zip not currently mounted
	MNTPNT="`mount | grep zip | awk '{print $3}'`"
	# if we are in FG mode, see if we already have a TC volume mounted
	if [ "$FG" == 1 ] ; then
		MNTPNT="`truecrypt --list | grep '/mnt/zip' | awk '{print $4}'`"
		if [ "$MNTPNT" ] ; then note "We have TC mounted already, using MNTPNT $MNTPNT"; fi
	fi
	
	echo "LEAVEMOUNTED is $LEAVEMOUNTED , MNTPNT is $MNTPNT, FG is $FG" 
	if [ "$FG" == 1 -a "$MNTPNT" ] ; then
		echo "Not doing a uz, since we are in fg mode and have a MNTPNT of $MNTPNT"
	elif [ ! "$LEAVEMOUNTED" -o ! "$MNTPNT" ] ; then
	    while [ "`mount | grep zip`" ]; do
		[ "$LEAVEMOUNTED" ] && break
		findzip -u
		killall truecrypt
    #	    umount /mnt/zip 2>/dev/null
		usleep 300000 2>/dev/null
		TMPCOUNT=`expr $TMPCOUNT + 1`
		if [ $TMPCOUNT -gt 3 ] ; then
		    usage exit "Cannot unmount ZIP drive. Make sure you don't have it as an active 
    directory somewhere and then re-run $PROG."
		fi
	    done
	    . /usr/local/sbin/findzip "$FINDZIPOPTS"
	    findzipdev "$FINDZIPOPTS"
	fi
	[ ! "$MNTPNT" ] && sleep 2 && findzipdev $FINDZIPOPTS
	if [ "$MNTPNT" ] ; then
	    TARDIR=$MNTPNT
	    ZIPSTATUS=$MNTPNT
	    # Refuse to proceed if we see a NEWER scrubhands on
	    # MNTPNT than this one running.
	    VERZIP=`$MNTPNT/scrubhands -v 2>/dev/null | sed "s,.* ,,g" | tr -d . | tr -dc '[0-9]'`
	    if [ "$VERZIP" ] ; then
		VERUS=`echo $SCRUBVER | tr -d . | tr -dc '[0-9]'`
		if [ "$VERZIP" -gt "$VERUS" ] ; then
                    note "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
		    note "\n\nYour $MNTPNT/scrubhands version is NEWER than $0.\n\n" \
			    "Please run this:\n\n   $MNTPNT/scrubhands -u -m\n\n" \
			    "and then after it successfully upgrades /usr/local/sbin/scrubhands) re-run\n\$COLOR_NORMAL\n" \
			    "  $SCRUBCMDLINE\n\n"
                    exit
		fi
	    fi
	    unset VERUS VERZIP
	fi
    fi
    echo "$ZIPSTATUS" > /tmp/zipstatus
    [ "$TARSONZIP" ] || TARSONZIP=1
    if [ $TARSONZIP -gt 1 ] ; then
	# If we have more than one tarball from zip, then some may be keys.tar.bz2 files
	[ "$TARDIR" ] && TAR=`ls -a1t $TARDIR/*.tar $TARDIR/*bz2 $TARDIR/*gz $TARDIR/*Z 2>/dev/null | egrep -iv "(jscanner.*|OPSDisk|FW.*).zip|routers.tar|\.20[0-9]{6}\-[0-9]{4}|opstuff|\/down\." | head -$TARSONZIP`
    else
	[ "$TARDIR" ] && TAR=`ls -a1t $TARDIR/*.tar $TARDIR/*bz2 $TARDIR/*gz $TARDIR/*Z 2>/dev/null | egrep -iv "(jscanner.*|OPSDisk|FW.*).zip|routers.tar|\.20[0-9]{6}\-[0-9]{4}|opstuff|\/down\.|\.keys\.tar\.bz2" | head -$TARSONZIP`
	[ "$TARDIR" ] && TARKEYS=`ls -a1t $TARDIR/*.tar $TARDIR/*bz2 $TARDIR/*gz $TARDIR/*Z 2>/dev/null | egrep "\.keys\.tar\.bz2"`
    fi

    # new 20081120: Start alwayspcap.pl in restart mode.
    # Old sniffs in old /current/tmp will close out, new ones in
    # new dir will begin. 
    echo ""         
    echo ""         
    type alwayspcap.pl > /dev/null &&     note "`date -u` Re-starting alwayspcap.pl." 
    type alwayspcap.pl > /dev/null &&       INTERFACE=$INTERFACE RESTART=yes alwayspcap.pl > /dev/null 2>&1 & 
    sleep 2         


    [ "$RTRBALLS" ] && RTRZIP="`find $TARDIR/$RTRBALLS -type f 2>/dev/null`"
    [ "$RTRZIP" ] && note Found router tarballs on $TARDIR:
    [ "$RTRZIP" ] && note "`echo $RTRZIP | tr \" \" '\n' | sed \"s/^/  /g\"`"


    #FWZIPFIND=`find $TARDIR/ $TARDIR/.. -name "FW*.zip" 2>/dev/null`
    #FWZIP=""
    #[ "$FWZIPFIND" ] && FWZIP=`ls -1rt $FWZIPFIND 2>/dev/null | grep -v RC | tail -1`
    FWZIP=`ls -1rt $TARDIR/FW*.zip $TARDIR/../*/FW*.zip 2>/dev/null | grep -v RC | tail -1`
    FWTARBZ=`ls -1rt $TARDIR/FW.*.tar.bz2 $TARDIR/../*/FW.*.tar.bz2 2>/dev/null | grep -v RC | tail -1`
    [ "$FWZIP" ] && FWBALL=`basename $FWZIP 2>/dev/null`
    [ "$FWTARBZ" ] && FWBALL=`basename $FWTARBZ 2>/dev/null`


    if [ "$TAR" ]; then
	OPSTUFF=`ls -a1t $TARDIR/opstuff* | head -1`
	if [ "$OPSTUFF" ] ; then
	    echo -e "\nComing soon to a scrubhands near you, automatic opbox upgrading!\n\n"
	    # TODO NOTES: Here need logic to:
	    #  0) unpack $OPSTUFF somewhere
	    #  1) terminate if this box has had this or greater version installed already
	    #  2) install portions of it that work on any hardware
	    #  3) determine this hardware rev
	    #  4) install portions of it specific to this hardware rev
	    #  5) determine if this opstuff install requires reboot and if so,
	    #     reboot box (with prompt and countdown....)
	fi
	# got op tarball(s) on zip - unpack it
	if [ -f "$TARDIR/stoicctrls.tar.bz2" ] ; then
	    STOICBALL="$TARDIR/stoicctrls.tar.bz2"
	    echo Replacing /current/bin/stoicctrls.tar.bz2 with one from $TARDIR:
	    ls -alrt /current/bin/stoicctrls.tar.bz2 $STOICBALL
	    cp -vp /current/bin/stoicctrls.tar.bz2 /current/bin/stoicctrls.tar.bz2.notused
	    cp -vp $STOICBALL /current/bin/stoicctrls.tar.bz2
	fi
	echo "Found these key tarball(s)
========
$TARKEYS
========"
	echo "Found these tarball(s)
========
$TAR"
	[ "$FWZIP" ] && echo $FWZIP
	[ "$FWTARBZ" ] && echo $FWTARBZ
	[ "$RTRZIP" ] && echo $RTRZIP | tr ' ' '\n'
	echo "========"
#	# If zip has newertools.tar.bz2, unpack that also
#	if [ -e /mnt/zip/newertools.tar.bz2 ] ; then
#	    TAR="$TAR /mnt/zip/newertools.tar.bz2"
#	fi
	# Check, if we have RC tarballs and are in upgrade mode, 
	# well that is a no-no.
	if [ "`echo $TAR | grep RC`$NEWPROG" ] ; then
	    if [ "$DOUPGRADE" = "yes" ] ; then
		eitheror=" RC tarball"
		[ "$NEWPROG" ] && eitheror=" $NEWPROG"
		findzip -u
#		umount /mnt/zip 2>/dev/null
		echo "Refusing to use -u option with$eitheror. Done here."
		exit
	    fi
	fi
	if [ "$DOUPGRADE" = "yes" ] ; then
	    note Upgrading, so skipping these file, not moving to $TOP/$DATE:
	    note  $FWZIP $FWTARBZ $STOICBALL $RTRZIP $TARKEYS $MNTPNT/$JSCANNERFILE . 2>/dev/null 
	    cp -vp $TAR . 2>/dev/null ; chown 0:0 *
	else
	    if [ ! "$NEWPROG" ] ; then
			if [ "$FG" == 1 ] ; then
				GOTALL=1
				note We are in FG mode, upgrades should be done already....
				CHECKFILES=""
			else			
				CHECKFILES="etc/autoutils bin/findzip bin/scrubhands bin/copy-what bin/fwrules.py bin/bashfunctions"
			fi
		PITCHTAR=`ls -a1t $TAR | grep PITCHIMPAIR.*bz2 | head -1`
		[ "$PITCHTAR" ] || notered exit "Odd, why no PITCHTAR?"
		note "Checking versions on station for:\n\n  $CHECKFILES"
		note against the files from $PITCHTAR
		ls -al $PITCHTAR
		( tar xjf $PITCHTAR $CHECKFILES >/dev/null 2>&1 ) &
		TOOLONG=60
		while [ 1 ] ; do
		    sleep 1
		    TOOLONG=$((TOOLONG-1))
		    GOTALL=1
		    for f in $CHECKFILES ; do
			[ -f $f ] || GOTALL=0
		    done
		    [ $GOTALL -gt 0 ] && break
		    [ $TOOLONG -gt 0 ] || break
		done
		[ $TOOLONG -gt 0 ] || notered exit Unpacking
		CHECKCOUNT=0
		for f in $CHECKFILES ; do
		    CHECKCOUNT=$((CHECKCOUNT+1))
		    note diff ./$f /usr/local/sbin
		    diff ./$f /usr/local/sbin && continue
		    note Upgrading /usr/local/sbin/`basename $f` from ./$f
		    notered BEFORE
		    ls -arlt /usr/local/sbin/`basename $f`* ./$f
		    \cp -vp /usr/local/sbin/`basename $f` /usr/local/sbin/`basename $f`.`date +%F-%H%M%S` 2>/dev/null
		    \cp -vp ./$f /usr/local/sbin/ && chmod +x /usr/local/sbin/`basename $f`
		    notered AFTER
		    ls -arlt /usr/local/sbin/`basename $f`* ./$f
		    GOTALL=0
		done
		
		if [ $GOTALL -eq 0 ] ; then
		    notered "\n\n$PROG just upgraded one or more vital scripts in /usr/local/sbin, try again.\n"
		    note "\n$SCRUBCMDLINE\n\n"
		    notered exit "You MUST re-run your scrubhands command, up-arrow or use the pastable above.\n\n"
		else
		    [ "$CHECKFILES" ] && note "\n\nAll $CHECKCOUNT are up to date\n\n"
		fi
		unset CHECKCOUNT CHECKFILES GOTALL TOOLONG PITCHTAR
	    fi

	    # redir stderr to null since $TAR may already be in .
	    note Copying files to $TOP/$DATE:
	    cp -vp $FWZIP $FWTARBZ $STOICBALL $RTRZIP $TARKEYS $TAR $MNTPNT/$JSCANNERFILE . 2>/dev/null ; chown 0:0 *
	fi
        #At this point go ahead and move our FG local data into our op dir
        if [ -d $FGTEMP/localCopy ] ; then
            note Copying our FG transferred files to $TOP/$DATE/fg
	    if [ -h /share/down/fg ]; then
		echo "/share/down/fg link already existed! Unlinking /share/down/fg!"
		unlink /share/down/fg
	    fi
            /bin/cp -prv $FGTEMP/localCopy /share/down/fg
	    note "Linking FG transfered files in /share/down/fg to /current/fg for your use on the unix station"
	    ln -vs /share/down/fg $TOP/$DATE/fg 
	    note "Fixing up permissions in fg directory /share/down/fg"
	    chmod -R o+rX /share/down/fg
        fi
	if [ "$FG" == 1 ] ; then
	  note "In FG mode - we won't be unmounting just yet to avoid race condition, we will do it at the end"
	elif [ ! "$LEAVEMOUNTED" -o "$FG" ] ; then
	  # got what we wanted--no sense leaving it mounted...
	  note unmounting /mnt/zip
	  findzip -u
#	  umount /mnt/zip 2>/dev/null
	fi
        # one of following two may fail--that's ok
	bzip2 -d *bz2 2>/dev/null
	gzip  -d *gz 2>/dev/null
	for TMP in `ls -at *.tar | egrep -v "stoicctrls.tar|newertools.tar|\.keys\.tar\.bz2"` ; do
	    C=.
	    [ -d .$$ ] && C=op2
	    [ -d op2 ] && C=op3
	    [ -d op3 ] && C=op4
	    [ -d op4 ] && C=op5
	    [ -d op5 ] && C=op6
	    [ -d op6 ] && C=op7
	    [ -d op7 ] && C=op8
	    [ -d op8 ] && C=op9
	    if [ "$C" = "." ] ; then
		if [ "$FG" == 1 ] ; then
			DOUPGRADE=no 
		    notered "Disabling auto-upgrade of /usr/local/bin in FG mode (should already be up to date)."
		elif [ "`echo $TMP | grep RC`$NEWPROG" ] ; then
		    # We force no upgrade with RC tarballs
		    DOUPGRADE=no 
		    notered "Disabling auto-upgrade of /usr/local/bin with RC tarball."
		fi
	    fi
	    echo ""
	    [ "${TMP:0:7}" = "ROUTER_" ] && C=.
	    echo $TMP | grep -q "\.keys\.tar"  && C=.
	    echo "Untarring $TMP into $TOP/$DATE/$C"
	    [ "$C" = "." ] || mkdir $C
	    tar -C $C -xvf $TMP
	    # marker .$$ for first time through is done...
	    mkdir .$$ 2>/dev/null
	done
	[ -e newertools.tar ] && \
	    notered Unpacking newertools.tar OVERWRITING $TAR && \
	    tar xvf newertools.tar
	rmdir .$$
	ZIP=$TAR
	if [ -z "`ls -alR | grep opscript.txt`" ]; then
	    echo -e "\nDOH!\a\n    Cannot find opscript.txt anywhere in $TOP/$DATE.\n"
            echo -e "     Let's try this again.\n"
	    # unpack failed reset TAR to "" so we stay in while loop
	    TAR=""
	    rm -rf $TOP/$DATE/*
	fi
    else
        echo "Looking on /dev/fd0 for tarball (can take a while, which is"
	echo $MINUSN "                                 part of why zip is better) "
	TAR=`tar xvf /dev/fd0 2>/dev/null`
	echo ""
	if [ -e "Systems" ]; then
	    rm -rf $TAR 2>/dev/null
	    TAR=""
	    echo -e "\a

Still the ISP floppy.
"
	fi
    fi
# end while [ ! "$TAR" ] ; do
done

if [ ! "$DOUPGRADE" = "yes" ] ; then 
  rm -vf /tmp/suiteinfo /tmp/suite.txt /suite.txt
  if [ "$GEN3" ] ; then
    ans=""
    while [ 1 ] ; do
        if [ "$SUITEOPTION" -a !"$ans" ] ; then
             ans=$SUITEOPTION
             SUITEOPTION=""
        else
	     note "You are on a GEN3 station ($GEN3)."
             echo -en "\nWhere are you (Room-Station)? "
             read ans
             echo
         fi
	TEST=`echo "$ans" | tr -dc '[0-9-]'`
	TEST=`echo "$ans" | grep "^[0-9][0-9]*-[0-9][0-9]*$"`
	[ "$TEST" = "$ans" ] && break
	notered "You must answer ##-##, you entered \"$ans\""
	continue
    done
    SUITELOC=$ans
    echo $SUITELOC > /root/suiteloc.txt
    echo GEN3 $SUITELOC $GEN3 |tee /tmp/suiteinfo
  else
    runsuite
  fi
  ls -al /tmp/suiteinfo

  if [ -d "/share/down" ] ; then
    note "Moving old /share/down contents to $TOP/$DATE/tmp/OLDSHAREDOWN"
    # OLDSHAREDOWN will not exist, we just made this stuff
    [ -f /share/down/down ] && mv -v /share/down/down  $TOP/$DATE/tmp/OLDSHAREDOWN
    [ -d /share/down ] || mkdir -pv /share/down
    ls -arltd /share/down/*  $TOP/$DATE/tmp/OLDSHAREDOWN/
    [ "$GEN3" ] || note "The OLDSHAREDOWN content will be wiped by getopdata\nat the end of the op."
  fi
  note "Starting Samba..."
  service smb restart | grep -v "^$"
  netstat -antp | grep :445.*LISTEN | sed "s/ *$//g"

  cat <<'EOF' > $TOP/$DATE/$TOOLS/shareon.sh
#!/bin/bash
    MSG="

Duping /current/down to /share/down/down as user fred via popped up xterm
running a new (niced +5) rsync every 10 seconds.

You can just stop it with a ^C, but only if no one needs it.
You can re-start it later whenever you like with \"1x -e shareon.sh\".

You can minimize this window.
"
    echo -e "$MSG"
    sleep 10
    while [ 1 ] ; do 
        START=`date +%s`
        nice -n 5 rsync -tvvr /current/down /share/down || break
        STOP=`date +%s`
        LEN=$((STOP-START))
        S=""
        if [ $LEN -gt 1 ] ;then
           S=s
        else
           LEN="ONLY $LEN"
        fi
        chown -R fred /share/down
        echo -e "\n\n\n`date`\n\n"
        echo -e "Last one took $LEN second$S. Next one begins in 10 seconds...\n"
        echo -e "$MSG"
        sleep 10
     done
EOF
  chmod +x $TOP/$DATE/$TOOLS/shareon.sh

  if [ ! "$NOSHAREON" ] ; then
	xterm -hold -title "automatic rsync of /current/down to /share/down" -e $TOP/$DATE/$TOOLS/shareon.sh &
  fi
  # Start ethwarn (after zip is mounted now)
  rm -f /tmp/filters.inuse
  note "No longer running /usr/local/bin/ethwarn, start it yourself if you want it
  (calls $TOP/$DATE/$TOOLS/ethwarn.pl):
  /usr/local/bin/ethwarn

"

  export SUITELOC GEN3 SUITENUM GEN3SITE GEN3SUITE

  # To turn on autocheckins, define DOCHECKINS to be non-empty.
  export DOCHECKINS
  

  note "Running getopdata -- Op Info Collector and Packer-Upper in another window..."
  (cd ; $TERM -hold -ie -name "OP Info Collector and OP Packer-Upper" -display $OPDATADISPLAY -geometry 207x70+1+0 -e  $TOP/$DATE/$TOOLS/getopdata viascrubhands)&

  # Build $TOP/$DATE/$DOWN/opnotes.txt.pregetopdata  and pop up editor for it
#  cat <<EOF >> $TOP/$DATE/$DOWN/opnotes.txt.pregetopdata   
#  cat <<EOF >> $TOP/$DATE/$DOWN/opnotes.txt
 cd $TOP/$DATE/$DOWN
#  (cd ; $TERM -name "OP Info Pre-opnotes.txt" -display $OPDATADISPLAY -geometry 135x56-0-0 -e  vim + $TOP/$DATE/$DOWN/opnotes.txt.pregetopdata )&
#  (cd ; $TERM -name "OP Info Pre-opnotes.txt" -display $OPDATADISPLAY -geometry 135x56-0-0 -e  vim + $TOP/$DATE/$DOWN/opnotes.txt )&

fi

if [ ! ${INTERFACE:0:3} = "ppp" ] ; then
  # If we are not using ppp, filter out these for ethwarn (this will
  # overwrite/override any leftover from previous op to these defaults)
  cat <<EOF > /tmp/filters.inuse
NetBeui
arp reply
802.1d config
netbios
pathcost
who-has
router
EOF
  note "Not using ppp, so ethwarn will filter out:\n`cat /tmp/filters.inuse | sed \"s/^/    /g\"`"
  (sleep 2 ; mv /tmp/filters.inuse /tmp/filters) &
fi

## BEGIN TARBALLS
# unpack several tarballs in background
# the sleeps (one per untar, then one after last block,
# will put all the "note"s together.
if [ ! "$DOUPGRADE" = "yes" ] ; then
    note Unpacking several tarballs in background
    if [ ls -l $TOP/$DATE/*.keys.tar $TOP/$DATE/*.keys.tar.bz2 2>/dev/null ] ; then
	sleep 1
	{
	    for keyfile in *.keys.tar ; do
		tar -C $TOP/$DATE -xf $keyfile
	    done
	    for keyfile in *.keys.tar.bz2 ; do
		tar -C $TOP/$DATE -xjf $keyfile
	    done
	    chown -hR 0.0 $TOP/$DATE
	} &
    fi
    if [ -f "$TOP/$DATE/$FWTARBZ" ] ; then
        note "\t$TOP/$DATE/$FWTARBZ"
        sleep 1
        {
            cd $TOP/$DATE/bin
            tar xvjf ../$FWTARBZ > /dev/null 2>&1
	    mv -v ../$FWTARBZ  $TOP/$DATE/tmp
	    chown -hR 0.0 $TOP/$DATE
        } &
    fi
    if [ -f "$TOP/$DATE/$FWBALL" ] ; then
	note "\t$TOP/$DATE/$FWBALL"
	sleep 1
	{
	    cd $TOP/$DATE/bin
	    unzip ../$FWBALL > /dev/null 2>&1
	    chown -hR 0.0 $TOP/$DATE
	} &
    fi
    #for routerfile in $RTRBALLS ; do
    #    if [ -f "$routerfile" ] ; then
    #        note "\t$routerfile"
    #        sleep 1
    #        {
    #	    tar -C $TOP/$DATE/ -xjf $routerfile
    #	    rm -f $routerfile
#	    chown -hR 0.0 $TOP/$DATE
    #        } &
    #    fi
    #done
    
    # Roottools is special, unpacks into / (BE CAREFUL)
    if [ -f "$TOP/$DATE/bin/roottools.tar.bz2" ] ; then
	note "\t$TOP/$DATE/bin/roottools.tar.bz2 (INTO /)"
	sleep 1
	{
	    tar -C / -xjf $TOP/$DATE/bin/roottools.tar.bz2
	    rm -f $TOP/$DATE/bin/roottools.tar.bz2
	    chown -hR 0.0 $TOP/$DATE
	} &
    fi
    
    # This set of loops catches a bunch of them, unpacks them
    # into wherever they were (bin or up), then deletes them
    # (all in the background).
    for tool in pork seconddate suctionchar ; do
	for dir in up bin ; do
	    for file in slyheretic_checks charm jackhelper curses orleans sift skimcountry crypttool enemyrun localtools dewdrops stoicctrls strifeworld tipoffs watcher \
		${tool}_clients ${tool}_implants \
		suctionchar_agents suctionchar_decodes ; do
		    if [ -f "$TOP/$DATE/$dir/$file.tar.bz2" ] ; then
			usleep 333000 2>/dev/null || sleep 1
			{
			    if [ -f "$TOP/$DATE/$dir/$file.tar.bz2" ] ; then
				note "$TOP/$DATE/$dir/$file.tar.bz2"
				tar -C $TOP/$DATE/$dir -xjf "$TOP/$DATE/$dir/$file.tar.bz2" 2>/dev/null
				rm -f "$TOP/$DATE/$dir/$file.tar.bz2"
			    fi
	    		    chown -hR 0.0 $TOP/$DATE
			} &
		    fi
	    done
	done
    done

    
    if [ -f "$TOP/$DATE/bin/varkeys/pitches.tar.bz2" ] ; then
	note "\t$TOP/$DATE/bin/varkeys/pitches.tar.bz2"
	sleep 1
	{
	    tar -C $TOP/$DATE/bin/varkeys -xjf $TOP/$DATE/bin/varkeys/pitches.tar.bz2
	    rm -f $TOP/$DATE/bin/varkeys/pitches.tar.bz2 
	    chown -hR 0.0 $TOP/$DATE
	} &
    fi
    if [ -f "$TOP/$DATE/bin/jlstuff.tar.bz2" ] ; then
	note "\t$TOP/$DATE/bin/jlstuff.tar.bz2"
	sleep 1
	{
	    tar --keep-old-files -C $TOP/$DATE/ -xjf $TOP/$DATE/bin/jlstuff.tar.bz2 2>/dev/null
	    rm -f $TOP/$DATE/bin/jlstuff.tar.bz2
	} &
    fi
    sleep 2
    mkdir -p $TOP/$DATE/bin/jscanner_pkg
    # jscanner only do one of the three possibilities, but do whole loop backgrounded
    # First in this order (debugging, you can put your own there as .tar.bz2 for instance
    for jfile in "$TOP/$DATE/bin/jscanner.tar.gz" "$TOP/$DATE/bin/jscanner.tar.bz2" "$TOP/$DATE/$JSCANNERFILE" "$TOP/$DATE/bin/$JSCANNERFILE" ; do
      if [ -f "$jfile" ]; then
	{
	    note "\t$jfile"
	    echo $jfile | grep -q zip$ && \
		unzip -qq -d $TOP/$DATE/bin/jscanner_pkg $jfile && \
		rm -f "$jfile"
	    echo $jfile | grep -q tar.bz2$ && \
		tar -C $TOP/$DATE/bin/jscanner_pkg -xjf $TOP/$DATE/bin/jscanner_pkg $jfile && \
		rm -f "$jfile"
	    echo $jfile | grep -q tar.gz$ && \
		tar -C $TOP/$DATE/bin/jscanner_pkg -xzf $TOP/$DATE/bin/jscanner_pkg $jfile && \
		rm -f "$jfile"
	    [ -e "$jfile" ] || \
		{
		chmod 751 $TOP/$DATE/bin/jscanner_pkg/externalScans/js.* \
		    $TOP/$DATE/bin/jscanner_pkg/externalScans/rpc* \
		    $TOP/$DATE/bin/jscanner_pkg/jscan.pl 2>/dev/null
		rm -rf $TOP/$DATE/bin/jscanner_pkg/jscan $TOP/$DATE/bin/jscanner.tar.bz2
		rm -rf $TOP/$DATE/bin/jscanner_pkg/scantypes/xprobe2.xml
	        # Once any ONE of these is unpacked, wipe them all, so we
	        # do only first we encounter in that order.
                rm -rf $TOP/$DATE/bin/jscanner_pkg/scantypes/telnetCommand.xml \
                     "$TOP/$DATE/bin/jscanner.tar.gz" "$TOP/$DATE/bin/jscanner.tar.bz2" \
                     "$TOP/$DATE/$JSCANNERFILE" "$TOP/$DATE/bin/$JSCANNERFILE"
		}
	}
      else
	continue
      fi
      [ -f "$jfile" ] && \
	notered Malformed JSCANNERFILE=$jfile not used && \
	rm -f "$jfile" && \
	continue
      break
    done &
    
    # Unpack morerats.tar.bz2
    $TOP/$DATE/$TOOLS/getmorerats
    # This sleep 1 so all the "note"s above are grouped together
    sleep 1
fi
## END OF TARBALLS



echo Directory: $TOP/$DATE
ls -al
if [ "$ZIP" = "" ]; then
  bzip2 -d *.bz2 2>/dev/null
  gzip2 -d *gz 2>/dev/null
  for TMP in `ls -at *.tar` ; do
    tar xvf $TMP
  done
fi

if [ "`ls -al $TOP/$DATE/$TOOLS | egrep -v \"getopdata|4x|ethwarn|doupgrade\" | tail --lines=+4`" = "" ]; then
  echo  ls -lR $TOP/$DATE
  ls -lR $TOP/$DATE
  echo ""
  echo "Bad vibes.  Your opdir appears to be empty. Above is a recursive ls of it."
  echo "This can happen when there's a tar floppy in drive that's doesn't have an"
  echo "op tarball on it."
  echo ""
  echo "Bailing now.  Fix your floppy, or use a ZIP."
  echo ""
  echo "Now wiping $TOP/$DATE for you (unless you ^C fast)."
  echo sleep 2
  sleep 4
  PIDSTOKILL=`ps -ewwwwf | grep perl | grep getopdata | grep -v grep | awk '{print $2}' | tr "\n" " " `
  kill $PIDSTOKILL
  PIDSTOKILL=`ps -ewwwwf | grep TCPDUMP | grep -v grep | awk '{print $2}' | tr "\n" " " `
  kill $PIDSTOKILL
  notered Wiping $TOP/$DATE in 5 seconds unless  you Ctrl-C NOW...
  sleep 5  &&  rm -rf $TOP/$DATE
  exit
fi
chown -h 0:0 $TOP/*
chown -hR 0:0 $TOP/$DATE &
echo Just Reset owner:group to 0:0 with:
echo chown -h 0:0 $TOP/\*
echo chown -hR 0:0 $TOP/$DATE

if [ -d $TOP/$DATE/TOOLS ]; then
  #never used I believe...
    TOOLS=TOOLS
    DOWN=DOWN
    TEXTS=TEXTS
    UP=TOOLS
    LOCALIPVAR=###LOCALIP###
fi

if [ "`grep random[0-9]*-[0-9]* $TOP/$DATE/$TEXTS/*script* 2>/dev/null`" ] ; then
  # randomizes random ports and such in scripts
  echo ""
  echo "RANDOMIZING random[0-9]*-[0-9]*-[0-9]* strings in $TEXTS/*scripts* ..."
  mkrandom
  echo "Done. (originals preserved in .premkrandom files)"
  echo ""
fi

if [ ! -d $TOP/$DATE/$DOWN ]; then
    mkdir -p $TOP/$DATE/$DOWN
fi

cd $TOP/$DATE/$DOWN

# make myenv show current pastables for tcpdump, scripted windows
# First set up the executable part of it, all but the first N+3 lines
rm -f /usr/local/bin/myenv 2>/dev/null
echo "" >> /usr/local/bin/myenv
LINE=`wc -l /usr/local/bin/myenv | awk '{print $1}'`
LINE=`expr $LINE + 3`
echo "tail --lines=+$LINE /usr/local/bin/myenv" >> /usr/local/bin/myenv
echo "exit" >> /usr/local/bin/myenv


# Build the new tcpdump.raw shell script
cat <<'EOF' > /usr/local/bin/tcpdumpwindow.new
#!/bin/bash
export INTERFACE=INTERFACEVALUE
export HOSTIP="HOSTIPVALUE"

die() {
  echo -e "$*" 1>&2
  exit 2
}
# Scripted by calling process we hope: script -af /TOPVALUE/DATEVALUE/down/tcpdump.raw
cd /TOPVALUE/DATEVALUE/down
TEST="`pschain | grep script.-af.tcpdump.raw`"
[ "$TEST" ] || TEST="`scriptcheck | grep tcpdump.raw`"
[ "$TEST" ] || die $0 must be run in a scripted window writing to /current/down/tcpdump.raw

while [ 1 ] ; do
        TEST=`ifconfig $INTERFACE 2>/dev/null | egrep "inet addr:[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*"`
        if [ "$TEST" ] ; then           
                ifconfig -a
		if [ "$HOSTIP" ] ; then
			echo $HOSTIP | grep -q "host " || HOSTIP="host $HOSTIP"
		fi
                tcpdump -n -n -tttt -i $INTERFACE $HOSTIP
                # Add this line to mark end of op
                echo Script done on `date +%c`
        else
                echo `date`: Waiting on $INTERFACE to come up...
                sleep 30
        fi
done
exit

EOF

#  $TERM -name tcp -title TCPDUMP -display $TCPDISPLAY -geometry 170x8+1963-18 &
#  if [ "$P" = "1" ]; then
#    TCPDUMP_CMD="tcpdump -n -n -tttt -i $ETHER host ${PALIP}"
#  else
#    TCPDUMP_CMD="tcpdump -n -n -tttt -i $INTERFACE"
#  fi
#  $TERM -name tcp -title TCPDUMP -display $TCPDISPLAY -geometry 170x8+1963-18 -e "cd $TOP/$DATE/$DOWN;/usr/bin/script -af tcpdump.raw -c \"sh -c \\\"/usr/local/bin/tcpdumpwindow\\\"\"" &
#

# The rest of myenv is catted out when myenv is run
echo "" >> /usr/local/bin/myenv
note "# TCPDUMP -- NOW STARTED AUTOMATICALLY" >> /usr/local/bin/myenv
#note "++ paste cd and script -af lines first, then next block, not all at once ++" >> /usr/local/bin/myenv
#echo "ifconfig -a" >> /usr/local/bin/myenv
note "++ Building and starting /usr/local/bin/tcpdumpwindow in a popup"
note "++ Rerun in scripted window if you lose it."
if [ "$P" = "1" ]; then
    # Used to be "host $PALIP" took off now with firewall
    sed -e "s,INTERFACEVALUE,$ETHER,g" \
	-e "s,HOSTIPVALUE,$PALIP,g"  \
	-e "s,TOPVALUE,$TOP,g" \
	-e "s,DATEVALUE,$DATE,g" \
	/usr/local/bin/tcpdumpwindow.new >  /usr/local/bin/tcpdumpwindow
    TCPDUMPTITLE="TCPDUMP on $ETHER host $PALIP"
    #echo "tcpdump -n -n -tttt -i $ETHER host ${PALIP}" >> /usr/local/bin/myenv
else
    sed -e "s,INTERFACEVALUE,$INTERFACE,g" \
        -e "s,HOSTIPVALUE,$PALIP,g"  \
        -e "s,TOPVALUE,$TOP,g" \
        -e "s,DATEVALUE,$DATE,g" \
        /usr/local/bin/tcpdumpwindow.new >  /usr/local/bin/tcpdumpwindow
    TCPDUMPTITLE="TCPDUMP on $INTERFACE"
    #echo "tcpdump -n -n -tttt -i $INTERFACE" >> /usr/local/bin/myenv
fi
chmod 700 /usr/local/bin/tcpdumpwindow
$TERM -name tcp -title "$TCPDUMPTITLE" -display $TCPDISPLAY -geometry 170x8+1963-18 -e "cd $TOP/$DATE/$DOWN;/usr/bin/script -af tcpdump.raw -c \"sh -c \\\"/usr/local/bin/tcpdumpwindow\\\"\"" &
echo "# --Run this to restart your bandwidth monitor window:"
echo "# --  /usr/local/bin/bwmon" >> /usr/local/bin/myenv
echo "# --These tcpdump ones no longer needed unless you lose that window:"
echo "# --  cd $TOP/$DATE/$DOWN" >> /usr/local/bin/myenv
echo "# --  /usr/bin/script -af tcpdump.raw" >> /usr/local/bin/myenv
echo "# --  /usr/local/bin/tcpdumpwindow" >> /usr/local/bin/myenv
echo "" >> /usr/local/bin/myenv
echo "" >> /usr/local/bin/myenv
note "# SCRIPT WINDOWS" >> /usr/local/bin/myenv
echo "" >> /usr/local/bin/myenv
echo "cd $TOP/$DATE/$DOWN" >> /usr/local/bin/myenv
echo "/usr/bin/script -af script.\$\$" >> /usr/local/bin/myenv
echo "" >> /usr/local/bin/myenv
echo "" >> /usr/local/bin/myenv
note "# ENV FOR WINDOWS" >> /usr/local/bin/myenv
echo "" >> /usr/local/bin/myenv
echo "cd $TOP/$DATE/$TOOLS" >> /usr/local/bin/myenv
echo "export DISPLAY=:0.0" >> /usr/local/bin/myenv
echo "PS1=\"\t \h \w> \"" >> /usr/local/bin/myenv
echo "export NHOME=/current" >> /usr/local/bin/myenv

#echo "PS1=\"\`uname -n\`# \"" >> /usr/local/bin/myenv
fixpath PATH=/usr/java/jre1.6.0_03/bin:$TOP/$DATE/$TOOLS:/usr/local/sbin:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin:$PATH >> /usr/local/bin/myenv
#echo "PATH=/usr/java/j2sdk1.4.2_01/bin/:$TOP/$DATE/$TOOLS:/usr/local/sbin:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin:\$PATH" >> /usr/local/bin/myenv
echo "export DISPLAY PS1 PATH; date; pwd; uname -a; netstat -rn ; ifconfig -a ; env | grep PATH" >> /usr/local/bin/myenv
echo -e "didthis\n" >> /usr/local/bin/myenv
LINE2=`wc -l /usr/local/bin/myenv | awk '{print $1}'`
LINE2=`expr $LINE2 - $LINE`
chmod 700 /usr/local/bin/myenv
echo "### NOTE: Now see those $LINE2 lines at any time by typing \"myenv\"." >> /usr/local/bin/myenv


# END MYENV

if [ "$DOUPGRADE" = "yes" ] ; then 
  # Only doing upgrade--do not bother with scripme
  $TOP/$DATE/bin/doupgrade
  exit
elif [ ! "$DOUPGRADE" = "no" ] ; then
  note "Running doupgrade -- upgrades /usr/local/sbin from /current/bin in another window..."
  EXPLOIT_SCRIPME="$TOP/$DATE/bin/doupgrade" scripme -F -t AUTOUPGRADE -X"-geometry 98x57+1290+0 -title \"UPGRADING /usr/local/sbin\""
fi

### Bandwidth monitor window ###
if [ -x $TOP/$DATE/bin/bwmon.py ] ; then
    cat <<EOF > /usr/local/bin/bwmon
ps -efwwwwwww | grep -v [0-9].grep | grep -q xterm.*Bandwidth.Mon || \\
  ($TERM -title "Bandwidth Monitoring $PUBLICETHER started \`date -u +%H:%M\` UTC" -geometry 87x5-0-24 -e "$TOP/$DATE/bin/bwmon.py -e $PUBLICETHER $TOP/$DATE/down/bwmonitor.txt")&

EOF
else
    cat <<EOF > /usr/local/bin/bwmon
ps -efwwwwwww | grep -v [0-9].grep | grep -q xterm.*Bandwidth.Mon || \\
  ($TERM -title "Bandwidth Monitoring $PUBLICETHER started \`date -u +%H:%M\` UTC" -geometry 70x5-0-24 -e "while [ 1 ]; do (echo;date -u;ifconfig $PUBLICETHER | grep RX) | tee -a /current/down/bwmonitor.txt ; sleep 5; done")&
EOF
fi
chmod 700 /usr/local/bin/bwmon
/usr/local/bin/bwmon

# rename scripme.override if they don't want it
[ "$NOSCRIPME" -a -e $TOP/$DATE/etc/scripme.override ] && \
    mv $TOP/$DATE/etc/scripme.override $TOP/$DATE/etc/scripme.override.ignored

# for now, only those with override will get scripme windows automatically
if  [ ! -x "/usr/local/bin/scripme" ] || \
    [ ! -x "/usr/local/bin/scripme.pl" ] || \
    [ ! -e $TOP/$DATE/etc/scripme.override ] ; then
  # do it the old way--no scripme -F
  cd $TOP/$DATE/$DOWN
  echo ""
  note "${TERM}S (4x will give you four nice ${TERM}s...see \"4x -h\")"
  echo "4x"
  
  echo ""
  note "RAT"
  RAT=`ls -lart $TOP/$DATE/$UP|grep \.uu|awk '{print $9}' | tail --lines=-1`
  RATLINE=`grep "^nc -l -p" $TOP/$DATE/$TEXTS/opscript.txt | grep \.uu$ | head -1`
  RAT2=`echo $RATLINE | awk '{print $6}'`
  if [ ! -f $TOP/$DATE/$UP/$RAT -a -f $TOP/$DATE/$UP/$RAT2 ] ; then
    RAT=$RAT2
  fi
  echo "cd $TOP/$DATE/$UP"
  if [ ! -z "$RATLINE" ] ; then
    echo "ls -la *.uu"
    echo $RATLINE
  else
    if [ -f $TOP/$DATE/$UP/$RAT ] ; then
      echo "ls -la $RAT"
      echo "nc -l -p 32177 -n -vv < $RAT"
    fi
  fi

  note "OPSCRIPT"
  echo "cd $TOP/$DATE/$TEXTS"
  SCRIPT=`ls -lart $TOP/$DATE/$TEXTS|grep opscript.txt|awk '{print $9}'|tail --lines=-1`

  #echo "(Paste following into gvim window that pops
  #up and triple-click as much as you like)"
  #gvim $SCRIPT
  echo "vim $SCRIPT"

  if [ "$P" = "1" ]; then
      PIP=`grep "^etherConfig" $TOP/$DATE/$TEXTS/$SCRIPT | awk '{print $2}'`
      echo ":%s/$PIP/${PALIP}/g"
      OLDPALROUTER=`grep "^etherConfig" $TOP/$DATE/$TEXTS/$SCRIPT | awk '{print $4}'`
      echo ":%s/$OLDPALROUTER/${PALROUTER}/g"
  fi
  echo ":%s/$LOCALIPVAR/$LOCALIP/g"
  echo ":%s#CURRENTDIR#\\$TOP\/$DATE\/$DOWN#g"
  echo ":1"
  echo ""
  /usr/local/bin/myenv
else
  # New way with scripme

  # fix opscript without pastables
  rm -rf /tmp/opscript.tmp
  SCRIPT=`ls -lart $TOP/$DATE/$TEXTS|grep opscript.txt|awk '{print $9}'|tail --lines=-1`
  SCRIPT="$TOP/$DATE/$TEXTS/$SCRIPT" 
  WORKINGDIR="`grep "^####[ ]*\/" $SCRIPT | head -1 | awk '{print $2}'`"
  [ -e ${SCRIPT}.prescrub ] ||  cp -pf $SCRIPT ${SCRIPT}.prescrub
  cp -pf $SCRIPT.prescrub /tmp/opscript.tmp
  if [ "$P" = "1" ]; then
    PIP=`grep "^etherConfig" $SCRIPT.prescrub | awk '{print $2}'`
    OLDPALROUTER=`grep "^etherConfig" $SCRIPT.prescrub | awk '{print $4}'`
    sed "s/${PIP}/${PALIP}/g" $SCRIPT.prescrub | sed "s/${OLDPALROUTER}/${PALROUTER}/g"  > /tmp/opscript.tmp
  fi
  sed "s/$LOCALIPVAR/$LOCALIP/g" /tmp/opscript.tmp | \
      sed "s#CURRENTDIR#$TOP/$DATE/$DOWN#g" | \
      sed "s#WORKINGDIR#$WORKINGDIR#g" > $SCRIPT
  rm -f /tmp/opscript.tmp
  echo "Running \"scripme -F\", to get some scripted xterms, your
opscript.txt in a vi window,  and a scripted tcpdump on $INTERFACE"
  INTERFACE=$INTERFACE LOCALIP=$LOCALIP scripme -F
fi
# endif scripme or not

# do a uz unless we want to leave mounted or are in FG mode 
# FG case: /mnt/zip is already a mounted TC volume
if [ ! "$LEAVEMOUNTED" ] ; then
  [ "$DEBUG" ] && notered "Debug is on, so not running findzip -u!!"
  if [ ! "$DEBUG"  ] ; then
	if [ "$FG" == 1 ]; then 
		notered "About to run a uz, make sure both ops stations are setup since we will be unmounting and removing truecrypt files. Hit enter to continue with uz"
		read pauseresponse
	fi
	findzip -u
	if [ "$FG" == 1 ] ; then 
		note "Here is your myenv again"
		/usr/local/bin/myenv 
	fi
  fi
  #  [ "$DEBUG" ] || umount /mnt/zip 2>/dev/null
fi
echo -e "GOT ONE!!"

if [ "$P" = "1" -a ! "$LOCALIP" = "$PALIP" ]; then
    echo ""
    echo ""
    echo ""
    echo ""
    $SETCOLOR_WARNING
    echo -e "\aUh-Oh:  Your local IP seems to be $LOCALIP but you said $PALIP"
    echo -e "\a        was your local IP on the command line. IS THIS A PROBLEM????\a"
    $SETCOLOR_NORMAL
    echo ""
    echo ""
    echo ""
    echo ""
    
fi

echo ""
echo ""
