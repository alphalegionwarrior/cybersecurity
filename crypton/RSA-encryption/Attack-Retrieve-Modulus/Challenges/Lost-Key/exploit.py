from pwn import *
from Crypto.Util.number import *
from Crypto.PublicKey import *
import math

def encrypt(m):
    m=long_to_bytes(m)
    r.recvuntil("cmd: ")
    r.sendline("A")
    r.recvuntil("input: ")
    r.sendline(m.encode("hex"))
    return int(r.recvline().strip(),16)

def decrypt(m):
    m=long_to_bytes(m)
    r.recvuntil("cmd: ")
    r.sendline("B")
    r.recvuntil("input: ")
    r.sendline(m.encode("hex"))
    return int(r.recvline().strip(),16)

r = process("./run.sh")
r.recvline().strip()
flag_enc = bytes_to_long(r.recvline().strip().decode("hex"))

# Finding the modulus
c1 = encrypt(2)
c2 = encrypt(3)
c3 = encrypt(5)
c4 = encrypt(2**2)
c5 = encrypt(3**2)
c6 = encrypt(5**2)
N = GCD(GCD(c1**2 - c4, c2**2 - c5), c3**2 - c6)
print "Modulus: ", N

for j in range(2, 1000000):
    assert N % j != 0

# LS Byte Oracle Attack
flag = "\n"
for i in range(1,60):
    inv = inverse(256**i, N)
    _multiplier = encrypt(inv)
    chosen_ct = flag_enc*_multiplier
    output = decrypt(chosen_ct)
    flag_char = (output - (bytes_to_long(flag)*inv) % N) % 256
    flag = chr(flag_char) + flag
    print flag
